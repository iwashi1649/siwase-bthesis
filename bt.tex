\documentclass[sotsuron]{kuee}

\usepackage[dvipdfmx]{graphicx}
\usepackage{here}
\usepackage{amsmath}
\usepackage{bm}
\usepackage{multirow}


\title{DNAストレージにおけるナノポアシーケンサーの読み出し特性を考慮した誤り訂正手法}
\etitle{Error Correction Method Considering the Reading Characteristics of Nanopore Sequencers in DNA Storage}
\author{岩瀬 真太郎}
\eauthor{Shintaro Iwase}
\professor{佐藤 高史 教授}
% \course{京都大学大学院情報学研究科}
% \department{知能情報学専攻}
\date{令和8年2月10日}

%%% 本文
\begin{document}
\maketitle			% 表題を出力
\begin{eabstract}		% 英文要旨を出力
In today's information society, large amounts of digital data are generated 
every day, and the amount of data worldwide continues to grow explosively. 
DNA storage has emerged as a promising solution for long-term archival storage 
due to its high information density and durability. While nanopore sequencers 
offer advantages in reading long DNA sequences at high speeds, they suffer from 
lower accuracy compared to short-read sequencers, particularly with insertion 
and deletion errors. Although existing error-correcting codes have been proposed 
for DNA storage with capability to correct these errors, their decoding algorithms 
have not been optimized for the specific characteristics of nanopore sequencers.

This study aims to optimize existing error correction methods 
specifically for DNA storage systems using nanopore sequencers. The proposed 
method incorporates two key improvements: (1) optimization of reward and penalty 
parameters based on statistical transition matrices that model nanopore reading 
characteristics, and (2) integration of confidence scores from the basecaller's 
CTC (Connectionist Temporal Classification) output into the decoding process. 
Additionally, to address accuracy degradation with longer DNA sequences, we 
propose a segmentation-based encoding scheme that divides sequences into short 
segments with separators and reinitializes the hash function at segment boundaries.

Simulation results demonstrate that the proposed method improves 
both decoding efficiency and accuracy. The optimized decoding algorithm reduces 
heap search operations by 64-68\% and bit deletion rates by 76-83\% compared to 
the existing method. The segmentation scheme maintains stable decoding accuracy 
even for DNA sequences up to 15,000nt without significantly increasing computational 
complexity. 
% After Reed-Solomon outer decoding, the proposed method achieves a 77\% 
% error rate reduction at 0.75 coding rate compared to the existing method. These 
% results demonstrate that the proposed optimization makes nanopore sequencers more 
% practical and effective for DNA storage applications.

\end{eabstract}
\tableofcontents		% 目次を出力

\chapter{序論}
情報化社会が進展した現代では，日々大量のデジタルデータが生成されており，
世界中のデータ量は爆発的に増加し続けている．
2025年の報告では
全世界のデジタルデータ量は173.4ゼタバイトにのぼると推定され，
2029年には527.5ゼタバイトに達すると予測されている\cite{statista_worldwide_data_created}．
これらの大量のデータのうち，約60\%はアクセス頻度の極めて低いコールドデータであることが
知られている\cite{dna_data_storage_alliance_2021_intro}．
コールドデータの中には，法令に基づき長期間保存が義務付けられているものや，
将来的に解析される可能性のある研究データなどが含まれており，
これらを消去することは困難である．
そのため，コールドデータを安価で長期間保存できるアーカイブストレージ技術が
求められている\cite{reinsel2017dataage2025,dna_data_storage_alliance_2021_intro}．

%導入 背景 DNAストレージ
近年，次世代のアーカイブストレージ技術としてDNAストレージが注目されている．
DNAストレージとは，デジタルデータを
アデニン(A)，シトシン(C)，グアニン(G)，チミン(T)の4種類の塩基配列に符号化し，
人工的に合成したDNAにデータを保存する技術である．
DNAストレージは，適切な保存環境下であれば数千年以上にわたりデータを保存することが可能な
高い耐久性を持つことに加えて，
体積あたりに保存可能な情報量が非常に大きいため
高い情報密度を実現できることが見込まれており，
コールドデータの保存に適した新たなストレージ技術として期待されている
\cite{akash2024_applicable,Ceze2019,dna_data_storage_alliance_2021_intro}．

%DNAストレージ シーケンサ
DNAストレージにおけるデータの読み出しでは，DNAシーケンサーを用いてDNAの塩基配列を
解析する\cite{Ceze2019}．
DNAシーケンサーは数十から数百bp
\footnote{base pair(塩基対) の略．2本鎖DNAの塩基配列長を表す単位．
1本鎖の場合はnucleotidesからntという単位を用いる．}
の短い塩基長のDNAを対象とした
ショートリードシーケンサー\cite{Simon2009}と，
数百から数万bpの長い塩基長のDNAを対象としたロングリードシーケンサー\cite{Amarasinghe2020}に大別されるが，
DNAストレージに関する現在までの多くの研究では，
SBS(Sequence By Synthesis)法\cite{SBS}と呼ばれる
技術を用いたショートリードシーケンサーが主に用いられてきた．
SBS法は大量のDNA断片を並列に高精度で解析することができるという利点があるが，
一度に解析できるDNAの塩基長が数百bp程度と短いことや，解析速度が遅いという欠点がある\cite{SBS}．
一方，ロングリードシーケンサーの一つであるナノポアシーケンサーは
一度に数十万bp程度の長い塩基長のDNAを高速に解析することができるため，
DNAストレージの読み出し用のシーケンサーとして実用的であると考えられる\cite{Amarasinghe2020}．
そこで，本研究ではナノポアシーケンサーによる読み出しを前提とした
DNAストレージに着目する．

ナノポアシーケンサーは高速で長い塩基長のDNAを解析できる一方で，
SBS法に比べて塩基配列の決定精度が低いことが知られており，
特に挿入・消失エラーが多いことが課題となっている\cite{Amarasinghe2020,Dorey2024}． 
そのため，DNAストレージにおいてナノポアシーケンサーを用いる場合，
置換・挿入・消失エラーに対応した誤り訂正符号の検討が重要である．

先行研究では，連続した同一塩基(ホモポリマー)の禁止や
GCの含有率に関する制限といったシーケンス制約を
満たしつつ，置換・挿入・消失エラーに対応可能なDNAストレージ向けの誤り訂正符号を提案し，
シミュレーションと実際に合成DNAを用いた実験により，
最大10\%程度の誤りを含む塩基配列からペタバイト規模のデータを
正確に復元できる可能性を示した\cite{HEDGES}．
しかし，先行研究はDNAストレージの読み出しにはショートリードシーケンサーを用いることを前提としており，
ナノポアシーケンサーの読み出し特性を考慮した誤り訂正符号の最適化は行われていない．
また，先行研究の提案手法では長い塩基長では復号精度が低下すると述べられており，
ナノポアシーケンサーのようなロングリードシーケンサーを用いて
長い塩基長を扱う場合の復号精度の向上も課題である．

本研究では，DNAストレージの読み出しにおいてナノポアシーケンサーを用いることを
前提とした誤り訂正手法を提案する．
既存の誤り訂正手法における復号アルゴリズムにおいて，
ナノポアシーケンサーの読み出し特性を考慮した最適化を行い，
復号処理の効率化と精度の向上を図る．
また，符号化プロセスにおいても長い塩基長のDNAを扱う際の精度の低下を
抑制するための手法を提案する．
提案手法に対してバイナリデータの符号化から
ナノポアシーケンサーを用いた読み出し，復号までの一連のプロセスに関する
シミュレーションを行い，その性能を評価する．

\chapter{DNAストレージの符号化・読み出しプロセス}
% 本章では，ナノポアシーケンサーによる遺伝子解析技術の概要と，
% DNAストレージにおける誤り訂正符号の一つであるHEDGES符号化・復号の概要について説明する．
% また，既存手法における課題と本研究の目的を述べる．
\section{DNAストレージの概要} \label{dna_storage}
DNAストレージは，デジタルデータをDNAの塩基配列に符号化し，
人工的に合成したDNAを保存媒体としてデータを保存する技術である．
% DNAストレージにおけるデータの保存と読み出しのプロセスの概要を図\ref{fig:dna_storage}に示す．
% \begin{figure}
%     \begin{center}
%         \includegraphics[width=150mm]{noimage.png}
%         \caption{DNAストレージの保存と読み出しのプロセス}\label{fig:dna_storage}
%     \end{center}
% \end{figure}
DNAストレージは以下の手順でデータの保存と読み出しを行う．
\begin{enumerate}
  \item 符号化\\
  まずバイナリデータをDNAの塩基配列に符号化する．
  % 符号化方法は様々な手法が提案されており，
  % 2ビットを1塩基に対応させる方法やビット列と塩基配列の対応表を用いる方法，
  % 後述するHEDGES符号化などがある\cite{Grass2015Robust,DNAFountain,HEDGES}．
  符号化では，DNA合成時のエラーの抑制や構造安定性の確保のために
  シーケンス制約が課される．シーケンス制約にはホモポリマーの禁止や
  GC含有率が一定範囲内に収まるようにする制約がある\cite{Gervasio}．
  また，復号の際に発生するエラーの訂正を考慮した冗長性を付加することに加えて，
  シーケンスの際に発生するエラーに対する耐性を持たせる必要がある．
  \item 保存\\
  符号化によって得られた塩基配列に基づいて人工的にDNAを合成する．合成されたDNAは
  保存密度と安定性を高めるため，乾燥状態で保管する方法が一般的である\cite{landsman2023the}．
  これにより数千年にわたるデータの長期保存が可能であると考えられている
  \cite{Grass2015Robust}．
  \item データ読み出し\\
  保存されたDNAからデータを読み出すにはまずDNAを取り出し，SBS法や\ref{nanopore}節で
  詳しく述べるナノポアシーケンサー
  などのDNAシーケンサーを用いて塩基配列を解析する．
  シーケンス時に発生するエラーには以下の3種類がある．
  \begin{itemize}
    \item 置換エラー(substitution): 読み出された塩基が本来の塩基とは異なる場合．
    \item 挿入エラー(insertion): 本来の塩基配列に存在しない塩基が読み出された場合．
    \item 消失エラー(deletion): 本来の塩基配列に存在する塩基が読み出されなかった場合．
  \end{itemize}
  これらのエラーを含む塩基配列から，誤り訂正を行いつつ元のバイナリデータを復元する．
\end{enumerate}

\section{HEDGES} \label{hedges}
HEDGES(Hash Encoded, Decoded by Greedy Exhaustive Search)は，シーケンス制約を満たしつつ，
置換・挿入・消失エラーに対応可能な誤り訂正手法である\cite{HEDGES}．
\subsection{符号化} \label{hedges_encoding}
HEDGESではデータをパケット単位で扱う．
各パケットは255本の固定長DNA鎖からなり，DNA鎖の塩基長は自由に設定できる．
符号化はビット列から誤り訂正能力をもたせたビット列への変換を行う
リードソロモン(RS)符号化と，そのビット列からさらに冗長性を付加させた
塩基配列に変換するHEDGES符号化の2段階で行う．
図\ref{fig:hedges_encoding}にHEDGES符号化の概要を示す．
\begin{figure}
    \begin{center}
        \includegraphics[width=150mm]{hedges.png}
        \caption{HEDGES符号化の概要}\label{fig:hedges_encoding}
    \end{center}
\end{figure}
はじめに，バイナリデータをパケット単位に分割し，
各パケットのビット列に対してRS符号化を適用し，1パケット分のビット列を得る．
このRS符号は外部符号と呼び，塩基配列からビット列への復号の際に発生したエラーを
最終的に訂正する役割を持つ．
次に，RS符号化を適用したビット列に対して内部符号であるHEDGES符号化を適用し，
塩基配列を生成する．
HEDGESはビット列から塩基配列への変換において，符号化率が可変である
という特徴を持つ．
% DNAの塩基は4種類あるため，1塩基あたり最大2ビットまで割り当てることが出来るが，
% この場合，符号化率は$r=1$であり冗長性がないため，誤り訂正能力を持たない．
符号化率を下げることで冗長性を付加し，誤り訂正能力を持たせることができる．

% ビット列から塩基配列の変換においては，ここでは符号化率$r=0.5$，
% すなわち1ビットを1塩基に対応させる場合の符号化手法について説明し，
% その後に他の符号化率への拡張方法について述べる．
以下に，HEDGESにおける具体的な符号化手順を示す．
まず，メッセージのビット列$\{b_i\}$が以下のように与えられたとする．
\begin{align}
  b_i, \quad i=0,1,2,\ldots M, \quad b_i \in \{0,1\}
\end{align}
% 符号化率$r=0.5$では，
% 各ビット$b_i$に対して塩基$C_i$を割り当てればよい．
% \begin{align}
%   C_i, \quad i=0,1,2,\ldots M, \quad C_i \in \{C_i^*\}
% \end{align}
任意の符号化率を実現するためには，各塩基へ割り当てるビット数を0ビットから2ビットの範囲で
規則的に変化させる．
そのため，ビット列$\{b_i\}$を0から2の長さを持つビット列$v_i$に分割する．
以下に，符号化率$r=0.750$の場合と$r=0.500$の場合と$r=0.333$の場合の$v_i$の構成例を示す．
\begin{align}
  r=0.750&: \quad v_0 = b_0b_1, \quad v_1 = b_2, \quad v_2 = b_3b_4, \quad v_3 = b_5, \quad v_4 = b_6b_7 \ldots \label{eq1} \\
  r=0.500&: \quad v_0 = b_0, \quad v_1 = b_1, \quad v_2 = b_2, \quad v_3 = b_3 \ldots \\
  r=0.333&: \quad v_0 = b_0, \quad v_1 = b_1, \quad v_2 = 0, \quad v_3 = b_2, \quad v_4 = b_3, \quad v_5 = 0 \ldots
\end{align}
ただし，式\eqref{eq1}において隣接するビットは2ビットの値を表している．
$r=0.750$では塩基へビット割り当て数は2ビットと1ビットが交互に繰り返される．
$r=0.500$では，1塩基に1ビットを割り当てる．
$r=0.333$では，塩基へのビット割り当て数は1ビット，1ビット，0ビットの順に繰り返される．
各ビット列$v_i$に対して塩基$C_i$を割り当てるとする．
\begin{align}
  &C_i, \quad i=0,1,2,\ldots N, \quad C_i \in \{C_i^*\}
\end{align}
ここで，$\{C_i^*\}$はシーケンス制約を満たすために$C_i$として許される塩基の候補集合であり，
直前の数塩基の出力に基づいて決定される．例えば，ホモポリマーの最大長に制約を設ける場合，
直前の塩基出力が最大長のホモポリマーとなっていれば，
次の出力候補から同一の塩基は除外される．
また，GC含有率の制約を設ける場合は，直前数塩基のGC含有率に基づいてAとTまたはCとGを
出力候補から除外する．したがって$\{C_i^*\}$の要素数$\#C_i^*$は
$0 < \#C_i^* \leq 4$の範囲で変化する．
$\{C_i^*\}$の各塩基には0から順に整数値が割り当てられているとする．
このとき，$i$番目の塩基$C_i$は以下の式で与えられる．
\begin{align}
  K_i &= F\left( S_i, I_i, V_i \right) \\
  C_i &=  K_i + v_i  \quad \left(\rm{mod} \#C_i^*\right) \label{encode}
\end{align}
ここで，$F$はハッシュ関数であり，$S_i$はDNA鎖のIDに基づくソルト，
$I_i$はビット位置のインデックス，$V_i$は直前の12ビット分の値である．
すなわち，各ビットに対応する塩基は，DNA鎖のID，ビット位置，直前のビット列に基づく
ハッシュ関数の値を目的のビットに加算し，出力塩基の候補数で剰余をとることにより，
擬似ランダムかつ一意に決定される．

% $r=0.5$以外の符号化率を用いる場合も基本的な考え方は同様である．$r=0.5$の場合は
% 1塩基に1ビットを対応させたが，他の符号化率を実現するには，各塩基へ割り当てる
% ビット数を0ビットから2ビットの範囲で規則的に変化させる．
% つまり，一般には出力塩基$C_i$に対応するものはビット$b_i$ではなく，0から2の長さを持つ
% ビット列$v_i$となる．
% 以下に，符号化率$r=0.750$の場合と$r=0.500$の場合と$r=0.333$の場合の$v_i$の構成例を示す．
% \begin{align}
%   r=0.750&: \quad v_0 = b_0b_1, \quad v_1 = b_2, \quad v_2 = b_3b_4, \quad v_3 = b_5, \quad v_4 = b_6b_7 \ldots \label{eq1} \\
%   r=0.500&: \quad v_0 = b_0, \quad v_1 = b_1, \quad v_2 = b_2, \quad v_3 = b_3 \ldots \\
%   r=0.333&: \quad v_0 = b_0, \quad v_1 = b_1, \quad v_2 = 0, \quad v_3 = b_2, \quad v_4 = b_3, \quad v_5 = 0 \ldots
% \end{align}
% ただし，式\eqref{eq1}において隣接するビットは2ビットの値を表している．
% $r=0.750$では塩基へビット割り当て数は2ビットと1ビットが交互に繰り返される．
% $r=0.500$では，1塩基に1ビットを割り当てる．
% $r=0.333$では，塩基へのビット割り当て数は1ビット，1ビット，0ビットの順に繰り返される．
% したがって，各ビット列$v_i$に対応する出力塩基を決定する式は，式\eqref{encode_half}の
% $b_i$を$v_i$に置き換えたものとなり，以下のように表される．
% \begin{align}
%   C_i = K_i + v_i = F( S_i, I_i, V_i ) + v_i \quad \left(\rm{mod} \#C_i^*\right) \label{encode}
% \end{align}

HEDGESでエンコードするビット列の先頭はDNA鎖のIDを表すビット列であり，
ID部分の符号化では$S_i=0$とされる．ビット列を符号化して得られた塩基配列の
両端にはプライマーと呼ばれる決められた塩基配列を付加され，最終的なDNA鎖の出力
となる．

\subsection{復号} \label{hedges_decoding}
HEDGESで符号化された塩基配列から元のデータを復元するには，まずHEDGES復号により
置換・挿入・消失エラーを訂正しながら塩基配列からビット列への復元を行い，
次に外部符号であるRS符号の復号を行うことで，HEDGES復号で復元に失敗したビット列の訂正を行う(図\ref{fig:hedges_encoding})．
HEDGES復号では
Greedy Exhaustive Search(貪欲探索法)に基づく復号アルゴリズムを用いる\cite{Astar}．
このアルゴリズムは
図\ref{fig:heap}に示すような
ビット列の候補に基づくヒープ構造を探索することで，
入力された塩基配列に対して尤もらしいビット列を選定する手法である．
各要素には候補のビット列と，挿入と消失を仮定するskewと呼ばれるパラメータが存在する．
skewは参照塩基を現在の位置からどれだけずらすかを表し，$\Delta \in \{-1, 0, 1\}$で表される．
\begin{figure}
    \begin{center}
        \includegraphics[width=100mm]{heap.png}
        \caption{HEDGES復号におけるヒープ構造}\label{fig:heap}
    \end{center}
\end{figure}
復号プロセスとしては，まずビット列$v_i$とskew$\Delta$の全ての組み合わせに対して
候補を生成し，ヒープに追加する．
各候補において，その$v_i$から式\eqref{encode}を用いて予測される
塩基$C_i$と，候補に対応する実際に入力された塩基$C'_i$を比較し，
一致していればスコアに報酬を加算し，不一致であればペナルティを加算する．
各ステップにおいてスコアが最小となる候補を選択し，これを親として次の候補を
展開していくことで，ヒープ構造を構築する．
skewの値によってステップごとのペナルティ$\Delta P$は，
報酬$P_{ok}$，
置換ペナルティ$P_{sub}$，
挿入ペナルティ$P_{ins}$，
消去ペナルティ$P_{del}$
を用いて
以下のように計算される．
\begin{itemize}
  \item $\Delta = 0$の場合: \\ 位置ずれはなく，一致または置換エラーを表す．
  \begin{align}
    \Delta P = \begin{cases}
      P_{ok} & (\text{一致の場合}) \\
      P_{sub} & (\text{不一致の場合})
    \end{cases}
  \end{align}
  \item $\Delta = -1$の場合:\\ 消失エラーを仮定するため，入力塩基の参照位置を一つ戻す．
  この場合は参照する塩基がないので比較は行われない． 
  \begin{align}
    \Delta P = P_{del}
  \end{align}
  \item $\Delta = 1$の場合: \\ 1塩基の挿入エラーを仮定するため，入力塩基の参照位置を一つ進める．
  \begin{align}
    \Delta P = \begin{cases}
      P_{ins} + P_{ok} & (\text{一致の場合}) \\
      P_{ins} + P_{sub} & (\text{不一致の場合})
    \end{cases}
  \end{align}
\end{itemize}
各仮説のスコアは，親仮説のスコアに$\Delta P$を加算することで蓄積されていく．
% そのため，仮説に誤りがある場合，後続の仮説のペナルティは急速に蓄積される特性がある．
これにより，正しい復号経路は他の経路に比べて顕著に低いスコアを持つようになり，
効率的に正しい復号経路を見つけることができる．
ただし，メッセージの末尾の数バイトでは，誤った仮説に対するペナルティが蓄積されるのに十分な
後続の塩基がないため，復号精度が低下する．これに対処するため，符号化時にメッセージ末尾に
2バイト分のrunoutと呼ばれるゼロパディングを追加し，復号時にはこれを除去する処理が行われる．

復号におけるヒープ探索処理では，計算の複雑性が爆発的に増加することを防ぐために，
ヒープサイズに上限を設け，上限に達した時点でデコードの失敗を宣言して探索を中止し，
DNA鎖の残りの部分をビット消失としてマークする．
復号失敗によるビット消失は外部符号であるRS符号によって最終的に訂正される．

\section{ナノポアシーケンサーとベースコーラー} \label{nanopore}
ナノポアシーケンサーはDNAが溶液中で帯電していることを利用して，
電気泳動現象によりDNAをナノポアと呼ばれるタンパク質の細孔に通過させることで
DNAの塩基配列を解析するシーケンサーである\cite{Amarasinghe2020,Dorey2024}．
図\ref{fig:nanopore}にナノポアシーケンサーによるDNA解析の概要を示す．
ナノポアシーケンサーのフローセルと呼ばれるセンサー基板上
には複数のナノポアタンパク質が配置されており，
その細孔の直径は約1nmで，1本のDNAのみが通過できる大きさになっている．
フローセルは塩化カリウムを含んだ電解質で満たされており，溶液中で
DNAは負に帯電しているため，電圧を印加することで電気泳動により電場の方向に移動する．
これによりDNAの進行方向を制御し，ナノポアへ誘導する．
誘導されたDNAはヘリカーゼと呼ばれる酵素によって2本鎖DNAから1本鎖DNAに解かれつつ，
一定の速度でナノポアを通過するように制御される．
このとき，ナノポアを通過するDNAがナノポア内のイオンの流れを阻害するため，イオン電流の大きさが
変化する．
イオン電流の変化は，ナノポアを通過中の塩基の並びによって異なるため，
電流の変化を解析することでDNAの塩基配列を決定することができる．
\begin{figure}
    \begin{center}
        \includegraphics[width=150mm]{nanopore.png}
        \caption{ナノポアシーケンサーの原理と手順}\label{fig:nanopore}
    \end{center}
\end{figure}

電流信号から塩基配列を決定するプロセスはベースコールと呼ばれ，ベースコーラーと呼ばれる
機械学習モデルによって行われる．本研究で使用するBonitoと呼ばれるベースコーラーの
アーキテクチャの概要を図\ref{fig:bonito}に示す\cite{bonito}．
Bonitoでは，まず入力された電流信号に対してCNNを適用し，
特徴量を抽出する．次に，LSTMを用いて電流信号の長距離の依存関係を捉え，
時系列データとしての特徴を抽出する．
その後，CTC出力層でLSTM出力に線形層を適用し，
空白(N)と4種類の塩基からなる
ラベル集合(N，A，C，G，T)に対するスコア系列を出力する．
このスコア系列に対してビームサーチを用いて最終的な塩基配列を決定する．
このとき，ラベル列に対してCollapseと呼ばれる以下の処理を適用する．
\begin{enumerate}
  \item 連続する同一ラベルを1つにまとめる．
  \item 空白ラベル(N)を削除する．
\end{enumerate}
これにより，例えばラベル列``AANNCCGNGGGTT''は
``ACGGT''に変換される．
\begin{figure}
    \begin{center}
        \includegraphics[width=150mm]{architecture.png}
        \caption{Bonitoアーキテクチャ概要}\label{fig:bonito}
    \end{center}
\end{figure}

DNAストレージの読み出しにナノポアシーケンサーを採用する利点としては
一度に数百bpから数百万bpの塩基長の長いDNAを直接的に解析できることや，
高速な解析が可能であることなどが挙げられる．
% 以下のような点が挙げられる\cite{Amarasinghe2020,Dorey2024,SBS}．
% \begin{itemize}
%   \item SBS法では一度に解析できるDNAの塩基長が数十bpから数百bpと短く，塩基長の長いDNAは
%   複数の断片に分割して解析する必要があるのに対し，ナノポアシーケンサーは一度に数百bpから数百万bpの
%   塩基長の長いのDNAを直接的に解析することが出来る．
%   \item SBS法では解析に数日から数週間を要するのに対し，ナノポアシーケンサーは400bp/s
%   での高速な解析が可能である．
%   \item ナノポアシーケンサーはリアルタイムでの解析が可能であり，解析するサンプルを
%   柔軟に制御できるため，必要なデータを効率的に取り出すことが出来る．
%   \item 小型で低コストな装置であるため，設置場所の制約が少なく，運用コストが低い．
% \end{itemize}
一方で，ナノポアシーケンサーはヘリカーゼを用いたDNAの進行速度の制御が難しく，
ベースコーラーでの塩基配列の推論が正確に行われない場合がある．
そのため，ナノポアシーケンサーはSBS法に比べて読み取り精度が低いことが知られており，
ナノポアシーケンサーを用いたDNAストレージでは，誤り訂正符号の検討が特に重要である\cite{Amarasinghe2020,Dorey2024}．

\section{既存手法の課題と研究目的} \label{sec:problem}
\cite{HEDGES}の研究における課題点としては，以下の点が挙げられる．
\begin{itemize}
  % \item 既存のHEDGES復号アルゴリズムにおいて，置換・挿入・消失エラーに対する
  % ペナルティ$P_{sub}$，$P_{ins}$，$P_{del}$の値は概念的には各エラーの発生確率の負の対数
  % であるとされているが，先行研究のシミュレーション評価においては，各エラーが等しい確率で
  % 発生する場合を想定して$P_{sub} = P_{ins} = P_{del}=1$と設定した上で，
  % いくつかの符号化率において最適な報酬$P_{ok}$の値を経験的に決定するにとどめられており，
  \item 既存研究では
  ナノポアシーケンサーを用いて塩基の読み出しを行う場合の統計的な出力特性に基づいた
  報酬とペナルティの最適化は行われていない．
  \item 既存のHEDGES復号アルゴリズムにおける入力は塩基配列であるため，
  ベースコーラーが出力する各時点における各塩基の確率分布を考慮した復号は行われない．
  \item 既存のHEDGES符号化・復号手法では，長い塩基配列では探索数が爆発し，
  ヒープの上限に達しやすく，復号失敗が起こりやすいため，復号精度が低下する．
\end{itemize}
本研究では，DNAストレージの読み出しにおいてナノポアシーケンサーを
用いることを前提とした誤り訂正手法を提案する．
HEDGES復号アルゴリズムにおける報酬とペナルティに関して，
ナノポアシーケンサーで塩基の読み出しを行う場合の
各塩基のエラーの発生確率や遷移確率といった統計的な読み出し特性を考慮した最適化を行う．
また，ベースコーラーによって出力される各塩基の確率分布も報酬とペナルティに反映させることにより，
復号における探索数の削減と精度の向上を図る．
さらに，符号化プロセスにおいても長い塩基長のDNAを扱う際の精度の低下を
抑制するための手法を提案する．
これらの提案手法に対してシミュレーションを実施し，その性能を評価する．

\chapter{提案手法}\label{proposed_method}
\section{復号の探索効率化} \label{optimization}
本節では，復号における探索の効率化を図るために，
ナノポアシーケンサーの統計的な読み出し特性とベースコーラー出力における
各時点での塩基の確率分布を考慮した報酬とペナルティの最適化手法を提案する．
まず，ナノポアシーケンサーの読み出し特性のモデル化と，ベースコーラーにおける
CTC出力の扱いについて説明し，その後にこれらを報酬とペナルティに反映させる手法について述べる．

\subsection{ナノポアシーケンサーの読み出し特性のモデル化} \label{stat_model}
ナノポアシーケンサーの読み出し特性をモデル化するために，事前に統計的なエラー率を
表現する遷移行列を作成する．
塩基配列の読み出しにおいて，読み出し後の塩基配列と本来の塩基配列が分かっているとき，
シーケンスアラインメントと呼ばれる手法を用いてこの2つの塩基配列を比較し，
一致部分や各種エラーの発生箇所を特定することができる
\cite{GOTOH1982705}．
アラインメントされた2つの塩基配列において，対応する塩基のペアが一致している場合は正しい
読み出しを表し，不一致の場合は置換エラーを表す．また，一方の配列の塩基が他方の配列の空白
に対応している場合は挿入・消失エラーを表す．
このようにして得られるアラインメント情報から，
DNA読み出しにおける正しい読み出しと
置換・挿入・消失エラーの発生という各事象は
4種類の塩基に空白(N)を含めた$\{N,A, C, G, T\}$の5種類のラベル間の
遷移として表すことができる．

これを用いてナノポアシーケンサーの統計的な読み出し特性を以下の行列$\bm{T}$で表す．
\begin{align}
  \bm{T} = \begin{bmatrix}
    0 & p_{AN} & p_{CN} & p_{GN} & p_{TN} \\
    p_{NA} & p_{AA} & p_{CA} & p_{GA} & p_{TA} \\
    p_{NC} & p_{AC} & p_{CC} & p_{GC} & p_{TC} \\
    p_{NG} & p_{AG} & p_{CG} & p_{GG} & p_{TG} \\
    p_{NT} & p_{AT} & p_{CT} & p_{GT} & p_{TT} \\
  \end{bmatrix}
\end{align}
この行列の各要素は，4種類の塩基が等しい割合で含まれる十分に長いDNA配列を
ナノポアシーケンサーで読み出す場合における，正しい読み出し，置換・挿入・消失エラーの
発生確率を
表し，$X,Y \in \{A,C,G,T\}$に対して
\begin{itemize}
  \item $p_{XX}$: 塩基Xが正しく読み出される確率
  \item $p_{XY}$: 塩基Xが塩基Yに置換される確率
  \item $p_{XN}$: 塩基Xが消失する確率
  \item $p_{NY}$: 塩基Yが挿入される確率
\end{itemize}
を表す．$\bm{T}$の全要素の和は1になる．
この行列$\bm{T}$の第1行第1列以外の各要素に対して自然対数をとって$-1$を乗じた行列
を$\bm{P}_{STATS}$とおき，後述の手法により報酬とペナルティの算出に利用する．

\subsection{CTC出力の扱い} \label{ctc_output}
\ref{nanopore}節で説明したように，ベースコーラーは通常，CTC出力に対して
ビームサーチを用いて最終的に塩基配列を出力するが，本研究の提案手法では
ベースコーラーでは塩基配列の決定までは行わず，CTC出力のスコア系列を直接出力する．
また，\ref{hedges_decoding}節で説明したように，既存のHEDGES復号アルゴリズムでは
塩基配列を入力とするが，提案手法ではCTC出力のスコア系列を
入力として利用する(図\ref{fig:optim})．これにより，各時点における出力塩基の確率分布を
復号アルゴリズムに反映させることができる．
\begin{figure}
    \begin{center}
        \includegraphics[width=150mm]{optim.png}
        \caption{提案手法の概要}\label{fig:optim}
    \end{center}
\end{figure}

CTC出力が$L\times 5$行列$\bm{S}$で与えられるとする．ここで，$L$は入力電流信号の長さに依存する
時系列長であり，各行は各時点における5種類のラベル$\{N,A,C,G,T\}$に対する
出力確率を表す．$\bm{S}$に対して，\ref{nanopore}節で説明したCollapseに相当する
以下の処理を適用して$\bm{S}'$を得る．
\begin{enumerate}
  \item $\bm{S}$において出力確率が最大となるラベルが連続している複数行に対し，
  各ラベルの確率の平均をとり，1行にまとめた行列を$\bm{S}'$とする．
  \item $\bm{S}'$から，空白ラベル(N)に対する確率が最大となっている行を削除する．
\end{enumerate}
% なお，これにより得られた行列$\bm{S}'$の各行で確率が最大となる塩基を選択することで
% 得られる塩基配列は，通常のベースコーラーの最終層でのビームサーチにおいてビーム幅を1と
% した場合のベースコール結果に相当する．
$\bm{S}'$の各要素に対して自然対数をとって$-1$を乗じた行列を$\bm{P}_{CTC}$とおく．
$\bm{P}_{CTC}$の各列の要素は，各時点において各塩基または空白が出力される
確率に基づくスコアを表す．
\ref{hedges_decoding}節で説明したように，
既存のHEDGES復号アルゴリズムでは，仮説から式\eqref{encode}を用いて予測される塩基と
対応する入力塩基を比較して，一致・不一致により報酬やペナルティを決定するが，
提案手法では，仮説から予測される塩基に対する出力確率に基づくスコアを
$\bm{P}_{CTC}$から取得し，これを用いて報酬やペナルティを決定する．

\subsection{報酬とペナルティの最適化} \label{reward_penalty_optimization}
既存手法では，報酬$P_{ok}$と置換・挿入・消失エラーに対する
ペナルティ$P_{sub}$，$P_{ins}$，$P_{del}$は一定値を用いるが，本研究では
\ref{stat_model}節および\ref{ctc_output}節で述べたナノポアシーケンサーの読み出し特性と
ベースコーラーのCTC出力を考慮した新しい報酬$P'_{ok}$と
ペナルティ$P'_{sub}$，$P'_{ins}$，$P'_{del}$を提案し，以下のように定義する．
\begin{equation}
  \begin{split}
    P'_{ok} = P_{ok} &+ \alpha_{ok}(\bm{P}_{STATS}(x_{hypo}, x_{max}(i))-\mu_{STATS\_ok}) \label{opt1} \\ 
   &+ \beta_{ok}(\bm{P}_{CTC}(i, x_{hypo})-\mu_{CTC\_ok}) 
  \end{split}
\end{equation}
\begin{equation}
  \begin{split}
    P'_{sub} = P_{sub} &+ \alpha_{sub}(\bm{P}_{STATS}(x_{hypo}, x_{max}(i))-\mu_{STATS\_sub}) \label{opt2} \\
    &+ \beta_{sub}(\bm{P}_{CTC}(i, x_{hypo})-\mu_{CTC\_sub})
  \end{split}
\end{equation}
\begin{equation}
  \begin{split}
    P'_{ins} = P_{ins} &+ \alpha_{ins}(\bm{P}_{STATS}(N, x_{max}(i-1))-\mu_{STATS\_ins}) \label{opt3}\\
    &+ \beta_{ins}(\bm{P}_{CTC}(i-1, x_{hypo})-\mu_{CTC\_ins})
  \end{split}
\end{equation}
\begin{equation}
  \begin{split}
    P'_{del} = P_{del} &+ \alpha_{del}(\bm{P}_{STATS}(x_{hypo}, N)-\mu_{STATS\_del}) \label{opt4}
  \end{split}
\end{equation}
ここで，$x_{hypo}$は仮説のビット列から出力される塩基を表し，$i$は仮説が参照する
$\bm{P}_{CTC}$の行番号を表す．また，$x_{max}(i)$は$\bm{P}_{CTC}$の$i$行目において
出力確率が最大となる塩基を表す．$\bm{P}_{STATS}(X,Y)\quad(x,y\in \{N,A,C,G,T\})$は$\bm{P}_{STATS}$における
ラベル$x$からラベル$y$への遷移に対応するスコアを表す．
$\bm{P}_{CTC}(i,X)$は，$\bm{P}_{CTC}$の$i$行目におけるラベル$X$のスコアを表す．
$\mu_{STATS\_ok}$，$\mu_{STATS\_sub}$，
$\mu_{STATS\_ins}$，$\mu_{STATS\_del}$はそれぞれ，正しい読み出し，置換エラー，
挿入エラー，消失エラー発生したときの$\bm{P}_{STATS}$のスコアの期待値を表し，
% すなわち
% \begin{align}
%   \mu_{STATS\_ok} &= \dfrac{\displaystyle \sum_{X \in \{A,C,G,T\}} p_{XX} \bm{P}_{STATS}(X,X)}{\displaystyle \sum_{X \in \{A,C,G,T\}} p_{XX}} \\
%   \mu_{STATS\_sub} &= \dfrac{\displaystyle \sum_{X,Y \in \{A,C,G,T\}, X \neq Y} p_{XY} \bm{P}_{STATS}(X,Y)}{\displaystyle \sum_{X,Y \in \{A,C,G,T\}, X \neq Y} p_{XY}} \\
%   \mu_{STATS\_ins} &= \dfrac{\displaystyle \sum_{Y \in \{A,C,G,T\}} p_{NY} \bm{P}_{STATS}(N,Y)}{\displaystyle \sum_{Y \in \{A,C,G,T\}} p_{NY}} \\
%   \mu_{STATS\_del} &= \dfrac{\displaystyle \sum_{X \in \{A,C,G,T\}} p_{XN} \bm{P}_{STATS}(X,N)}{\displaystyle \sum_{X \in \{A,C,G,T\}} p_{XN}}
% \end{align}
% である．
$\mu_{CTC\_ok}$，$\mu_{CTC\_sub}$，
$\mu_{CTC\_ins}$はそれぞれ，$\bm{P}_{CTC}$において
正しい読み出し，置換エラー，挿入エラーに対応するスコアの統計的な期待値を表す．
報酬と各ペナルティは，固定の値$P_{ok}$，$P_{sub}$，$P_{ins}$，$P_{del}$に対して，
期待値が0になるように正規化された補正項を加算することで計算される．
各補正項には，調整用のパラメータ$\alpha_{ok}$，$\alpha_{sub}$，$\alpha_{ins}$，$\alpha_{del}$，
$\beta_{ok}$，$\beta_{sub}$，$\beta_{ins}$が乗じられており，
シミュレーションにより固定のペナルティと各補正項の重み付けを最適化する．
各定数の設定方法やパラメータの最適化手法については付録で詳しく述べる．
% まず，仮説のビット列から出力される塩基を$x_{hypo}$とする．
% また，仮説が参照する$\bm{P}_{CTC}$の行番号を$i$とする．
% このとき，$\bm{P}_{CTC}$の$i$行目において出力確率が最大となる塩基を
% $x_{max}(i)$とする．

\section{ロングリードに向けた符号化アルゴリズムの改良} \label{long_read_encoding}
\ref{sec:problem}節で述べたように，既存のHEDGES符号化・復号手法では
DNAの塩基長を長くすると復号精度が低下する．
これは，復号アルゴリズムにおいて仮説数がヒープサイズの上限に達した場合に
復号失敗としてその後のビット列をすべて消失として扱うため，
塩基長が大きくなるほど復号失敗の発生率が高くなることに起因している．
本節では，長い塩基長のDNAを扱う際の精度の低下を抑制するための
符号化・復号アルゴリズムの改良手法を提案する．

HEDGESの符号化アルゴリズムでは，各ビット列$v_i$に対応する
出力塩基$C_i$は式\eqref{encode}により，
DNA鎖のID，ビット位置，直前のビット列に基づく
ハッシュ関数を用いて連鎖的に決定される．
そのため，例えばDNA鎖のある位置でバースト誤りが発生した場合，
後続の塩基配列の復号に対しても連鎖的に影響を及ぼし，正しい復号経路の
探索が困難になる．
そこで，提案手法では図\ref{fig:segment}のように長い塩基配列を400ntのセグメントに分割し，
各セグメントの先頭で，ハッシュ関数の入力として用いるビット位置$I_i$と
直前のビット列情報$B_i$を0に初期化して符号化する．
セグメントの区切り位置を特定するために，隣接するセグメント間には
特定のパターンを持つ10塩基程度のセパレータを挿入する．
セパレータのパターンとしては，ホモポリマーがなく，GC含量が50\%程度となるような
塩基配列を選択する．本手法では”GTACTGCATG”という塩基配列をセパレータとして用いる．

復号時にはまず，以下の手順でセパレータの位置を検出する．
\begin{enumerate}
  \item $n=l_{p} + l_{seg}$とする．ただし$l_p$はプライマー長，$l_{seg}$はセグメント長を表す．
  \item $n-30<k<n+30$を満たす整数$k$対して$S_{match}(k)$を以下の式で計算し，
  $S_{match}(k)$を最小とする$k$をセパレータの位置として選択し，これを$k'$とする．
  \begin{align}
    S_{match}(k) = \sum_{j=0}^{l_{sep}-1} \bm{P}_{CTC}[k+j, S[j]] \label{eq:separator_detection}
  \end{align}
  ただし$S[j]$はセパレータ配列の$j$番目の塩基を表し，$l_{sep}$はセパレータ配列の長さを表す．
  \item $n=k' + l_{sep}+l_{seg}$とする．
  \item 2から3を繰り返し，全てのセグメントのセパレータ位置を検出する．
\end{enumerate}
セパレータの位置が特定できたら，各セグメントごとに
\ref{hedges_decoding}節で説明した復号アルゴリズムを適用し，
各セグメントの先頭では$I_i$と$B_i$を0に初期化した上でヒープを初期化して
復号を行う．
これにより，ヒープサイズが上限を超えることによる復号失敗を抑制し，
復号失敗が発生した場合でも，その影響をセグメント内だけに限定することができ，
次のセグメントから復号を再開することができる．
\begin{figure}
    \begin{center}
        \includegraphics[width=150mm]{segment.png}
        \caption{提案手法による符号化方式}\label{fig:segment}
    \end{center}
\end{figure}

\chapter{シミュレーション} \label{simulation}
本章では，シミュレーションを用いて提案手法の性能を評価する．
\ref{sim1}節では\ref{optimization}節で提案した報酬とペナルティの最適化手法を用いる場合の
復号時の探索数と復号精度を計測し，既存手法を用いる場合と比較してその有効性を評価する．
\ref{sim2}節では\ref{long_read_encoding}節で提案した
ロングリードに向けた符号化・復号アルゴリズムの改良手法を用いた場合の
復号精度を計測し，既存手法を用いる場合と比較してその有効性を評価する．

\section{復号の探索効率化} \label{sim1}
\subsection{実験方法}
\ref{optimization}節で提案した報酬とペナルティの最適化手法の
性能をシミュレーションにより評価するための実験手順の概要を図\ref{fig:sim1}に示す．
\begin{figure}
    \begin{center}
        \includegraphics[width=150mm]{simu1.png}
        \caption{シミュレーション手順概要}\label{fig:sim1}
    \end{center}
\end{figure}
予備実験として，シミュレーションによりナノポアシーケンサーの読み出し特性を評価し，
行列$\bm{P}_{STATS}$を得た．
次に，ランダムバイナリを用いた符号化・復号シミュレーションにおいて，
復号時のヒープ探索数を目的関数とする勾配降下法により，式\eqref{opt1}から\eqref{opt4}
における各補正項のパラメータを最適化した．
パラメータの最適化は複数の符号化率に対して独立に行い，
ナノポアシーケンサーの出力特性に基づく補正項のみを用いる場合と，
CTC出力に基づく補正項のみを用いる場合，両方の補正項を用いる場合の
3通りについて行った．
以上の予備実験の具体的な手順や条件については付録で詳しく述べる．

予備実験で得られた最適なパラメータを用いて，提案手法の復号性能を評価した．
まず，テストに用いるバイナリデータをHEDGESで符号化し，
得られたDNA鎖に対し，
ナノポアシーケンサーによる電流波形をSquigulator\cite{squigulator}と呼ばれるシミュレータを用いて
シミュレーションした．
次に，シミュレーションされた電流波形に対して，Bonitoでベースコールを行った．
このとき，最終的な塩基配列だけでなく，CTCデコード前のCTCスコア行列も出力するようにした．
このベースコール結果を用いて，既存手法および提案手法による復号を行い，ヒープの探索数，
復号失敗による消失ビット数，RS復号後の最終的なビット誤り率を計測した．
既存手法を用いた復号では，ベースコーラーが出力する塩基配列を入力とする．
提案手法を用いた復号では，CTCスコア行列を入力とし，ナノポアシーケンサーの読み出し特性に基づく
補正項のみ用いる場合・CTC出力に基づく補正項のみ用いる場合・両方の補正項を用いる場合の3通りについて
評価を行った．このバイナリデータの符号化から復号までの一連のシミュレーションを，
複数の符号化率について実施した．

\subsection{実験条件}
テスト用のバイナリデータには，「こころ」(夏目漱石著)の全文のテキストデータ(UTF-8形式)を
青空文庫から取得し，ルビ部分(《…》で囲まれた部分)を正規表現により除去した
ものを使用した\cite{kokoro}．このデータのサイズは481158バイトである．
このバイナリデータをHEDGESで符号化は，
符号化率
$0.75,0.60,0.50,0.33$で行い，塩基長は400ntとした．
Squigulatorを用いたナノポアシーケンサーの電流値シミュレーションでは，
MinION R9.4.1フローセルを想定したパラメータ設定を用いた\cite{squigulator}．
Bonitoのモデルには，既存の学習済みモデル%であるdna\_r9.4.1@v2
をHEDGESで符号化したDNAの読み出しに向けてファインチューニングしたものを使用した\cite{bonito}．
既存手法及び提案手法による復号において，ヒープの上限サイズは1000000とした．

\subsection{結果と考察}
既存手法と提案手法の復号性能評価における，
DNA鎖1本あたりの平均ヒープ探索数，復号失敗によるビット消失率，
RS復号後の最終的なビット誤り率を
表\ref{tab:results_heap}, \ref{tab:results_deletion}, 
\ref{tab:results_final_ber}に示す．
ただし，各表において，
%「Default」は既存手法によるベースコールと復号を表し，
「STATSのみ」はナノポアシーケンサーの読み出し特性に基づく補正項のみを適用した場合を表し，
「CTCのみ」はCTC出力に基づく補正項のみを適用した場合を表し，
「STATS+CTC」は両方の補正項を適用した場合を表す．
\begin{table}
  \centering
  \caption{DNA鎖1本あたりの平均ヒープ探索数}
  \label{tab:results_heap}
  \begin{tabular}{c|c|cccc}
    \hline
    \multicolumn{2}{c|}{符号化率} & 0.75 & 0.6 & 0.5 & 0.33 \\
    \hline
    \multicolumn{2}{c|}{既存手法} & 135550 & 45219 & 21291 & 12290 \\
    \hline
    \multirow{3}{*}{提案手法} & STATSのみ & 77281 & 23707 & 10893 & 4785 \\
    \cline{2-6}
     & CTCのみ & 53098 & 17966 & 9353 & 4354 \\
    \cline{2-6}
     & STATS+CTC & 48507 & 14972 & 7625 & 3894 \\
    \hline
  \end{tabular}
\end{table}
\begin{table}
  \centering
  \caption{ビット消失率}
  \label{tab:results_deletion}
  \begin{tabular}{c|c|cccc}
    \hline
    \multicolumn{2}{c|}{符号化率} & 0.75 & 0.6 & 0.5 & 0.33 \\
    \hline
    \multicolumn{2}{c|}{既存手法} & 0.03083 & 0.00949 & 0.00341 & 0.00328 \\
    \hline
    \multirow{3}{*}{提案手法} & STATSのみ & 0.00741 & 0.00376 & 0.00121 & 0.00076 \\
    \cline{2-6}
     & CTCのみ & 0.00789 & 0.00265 & 0.00111 & 0.00055 \\
    \cline{2-6}
     & STATS+CTC & 0.00693 & 0.00229 & 0.00069 & 0.00056 \\
    \hline
  \end{tabular}
\end{table}
\begin{table}
  \centering
  \caption{RS復号後のビット誤り率}
  \label{tab:results_final_ber}
  \begin{tabular}{c|c|cccc}
    \hline
    \multicolumn{2}{c|}{符号化率} & 0.75 & 0.6 & 0.5 & 0.33 \\
    \hline
    \multicolumn{2}{c|}{既存手法} & 0.022981 & $<10^{-6}$ & $<10^{-6}$ & $<10^{-6}$ \\
    \hline
    \multirow{3}{*}{提案手法} & STATSのみ & 0.059977 & $<10^{-6}$ & $<10^{-6}$ & $<10^{-6}$ \\
    \cline{2-6}
     & CTCのみ & 0.008228 & $<10^{-6}$ & $<10^{-6}$ & $<10^{-6}$ \\
    \cline{2-6}
     & STATS+CTC & 0.005173 & $<10^{-6}$ & $<10^{-6}$ & $<10^{-6}$ \\
    \hline
  \end{tabular}
\end{table}
実験結果では，提案手法を用いることで，各符号化率において
既存手法と比べてヒープ探索数を削減し，復号失敗率を低減することができた．
ナノポアシーケンサーの読み出し特性に基づく補正項のみ適用した場合，
ヒープ探索数が43\%から61\%削減され，ビット消失率は60\%から77\%低減した．
CTC出力に基づく補正項のみ適用した場合，
ヒープ探索数が56\%から65\%削減され，ビット消失率は68\%から83\%低減した．
また，これら両方の補正項を適用した場合には，
ヒープ探索数は64\%から68\%削減され，ビット消失率は76\%から83\%低減し，
もっとも良好な結果が得られた．
さらに，RS復号後の最終的なビット誤り率については，符号化率0.75において，
両方の補正項を適用した場合，既存手法と比べて77\%の誤り率低減が達成された．
以上の結果から，提案手法により復号の探索が効率化されると同時に，
復号失敗によるビット消失率が低減されるため，最終的な復号精度の向上にも寄与することが
示された．

\section{ロングリードに向けた符号化アルゴリズムの改良} \label{sim2}
\subsection{実験手法}
\ref{long_read_encoding}節で提案した符号化・復号アルゴリズムの改良手法の
性能をシミュレーションにより評価するために，
セグメント化を行わない既存手法と，提案手法によりセグメント化を行う場合で
符号化・復号のシミュレーションを行い，復号における探索数，復号精度を比較した．

まず既存のHEDGES符号化アルゴリズムにより，テスト用のバイナリデータを
符号化した．得られたDNA鎖に対して\ref{sim1}節の実験
と同様の手法で電流波形のシミュレーションとベースコールを行った．
このベースコール結果に対して\ref{optimization}節の提案手法
により復号を行い，各パラメータは\ref{sim1}節の実験で得られたものを使用した．
これをDNA鎖1本の塩基長を500ntから15000ntの範囲で変化させながら行い，
HEDGES復号におけるビット誤り率を計測した．
また，既存手法による符号化は，塩基長を変えてもヒープ上限は一定値とする場合と，
ヒープ上限を塩基長に比例して増加させる場合の2通りについて評価を行った．

次に，同じバイナリデータを用いて，提案手法によるセグメント化を適用した符号化を
行い，同様に電流波形のシミュレーションとベースコールを行った．
復号においては，まずセパレータの位置を検出する必要があるため，
CTC出力に対して\ref{ctc_output}節で説明した方法で得られた$\bm{P}_{CTC}$
に対して\ref{long_read_encoding}節の方法でセパレータの検出を行った後，
セグメントごとに\ref{optimization}節の提案手法を用いて
復号を行った．
これをセグメント長は一定として，セグメント数を変化させることでDNA鎖全体の
塩基長を500nt程度から15000nt程度の範囲で変化させながら行い，
HEDGES復号におけるビット誤り率を計測した．


\subsection{実験条件}
テスト用に用いたバイナリデータは\ref{sim1}節の実験で使用したものと同じである．
また，Squigulatorによる電流値シミュレーションのパラメータ設定，
ベースコーラーのモデルについても\ref{sim1}節の実験と同様に行った．
既存手法及び提案手法による符号化における符号化率は0.60とした．
提案手法におけるセグメント化では，セグメント長は400ntとした．
復号におけるヒープ探索では，既存手法では塩基長に関わらずヒープサイズの上限を
1000000とした場合と，塩基長が400ntのときのヒープサイズ上限を1000000とし，
これを基準としてヒープサイズ上限を塩基長に比例して増加させる場合の2通りについて評価を行った．
提案手法におけるセグメントごとの復号では，ヒープサイズの上限を各セグメントごとで
1000000とした．

\subsection{結果と考察}
既存手法と提案手法における，DNA鎖の塩基長とビット誤り率の関係を
図\ref{fig:long_read_results1}に，塩基長とDNA鎖1本あたりの平均ヒープ探索数の関係を
図\ref{fig:long_read_results2}に示す．
ここで，
既存手法(1)はヒープサイズの上限を塩基長に関わらず一定とした場合，
既存手法(2)はヒープサイズの上限を塩基長に比例して増加させる場合を表す．
実験結果では，既存手法(1)では\cite{HEDGES}の研究の報告と同様に，
塩基長が大きくなるほどビット誤り率が直線的に増加することを確認した．
また，既存手法(2)では塩基長に比例してヒープサイズの上限を増加させることで
塩基長に対してビット誤り率を一定に抑えることができたが，ヒープ探索数は3つの
手法の中で最も大きくなった．
一方，提案手法においては塩基長が長くなってもビット誤り率は
ほぼ変化しなかった．
提案手法におけるヒープ探索数の上限は，各セグメントごとに1000000としているため，
DNA鎖全体での上限を1000000とした既存手法(1)と比較すると24\%ほど増加したが，
既存手法(2)と比較すると21\%ほど削減できた．

既存手法における復号精度の低下は，
復号におけるヒープ探索数の増加に伴う復号失敗率の増加が主な要因であり，
提案手法ではセグメントごとにハッシュ関数の入力とヒープを初期化することで，
ヒープサイズを抑えつつ，復号失敗が発生した場合においても
次のセグメントからの復号を継続できるため，復号精度の低下を抑制できたと考えられる．
\begin{figure}
  \centering
  \includegraphics[width=120mm]{longread1.png}
  \caption{塩基長とビット誤り率の関係}
  \label{fig:long_read_results1}
\end{figure}
\begin{figure}
  \centering
  \includegraphics[width=120mm]{longread2.png}
  \caption{塩基長とDNA鎖1本あたりの平均ヒープ探索数の関係}
  \label{fig:long_read_results2}
\end{figure}
\chapter{結論}
本研究では，DNAストレージの読み出しにおいてナノポアシーケンサーを用いることを前提とした
誤り訂正手法を提案し，その性能をシミュレーションにより評価した．
既存手法であるHEDGESは，DNAストレージにおけるシーケンス制約を満たしつつ
挿入・消失・置換エラーへの耐性を持つ誤り訂正符号であるが，
その復号アルゴリズムにおいて，
ナノポアシーケンサーでのDNA読み出しを前提とした最適化が行われていないという課題と，
DNA鎖の塩基長が長い場合に復号精度が低下するという課題が存在した．

本研究では，これらの課題を解決するために，
まずHEDGESの復号アルゴリズムにおいて，
ナノポアシーケンサーの統計的な読み出し特性とベースコーラーのCTC出力を
考慮した探索手法を提案した．
実験結果より，提案手法では既存手法と比較して復号アルゴリズムにおける探索数を
64\%から68\%削減し，
復号失敗によるビット消失率を76\%から83\%低減できることを示した．
さらに，ロングリードに向けた符号化・復号アルゴリズムの改良を提案し，
セグメント化による手法を用いることで長い塩基長のDNAを扱う場合の
復号精度の低下を抑制できることを示した．

今後の課題としては，以下の点が挙げられる．
第一に，ナノポアシーケンサーの出力特性をより詳細にモデル化することである．
本研究では，ラベル間の遷移確率のみを考慮した単純なモデルを用いたが，
塩基配列のコンテキスト依存性や，バースト的なエラー発生など，
より複雑な特性を考慮することで，復号における探索をより最適化できる可能性がある．
第二に，ベースコーラーの最新アーキテクチャに対応することである．
本研究で使用したBonitoはCNN-LSTM-CTC構成であるが，
最新のベースコーラーではCRFを用いたアーキテクチャなど，より先進的な機械学習手法が採用されており，
これらに対応することで復号精度のさらなる向上が期待できる．
第三に，実際のDNAを用いた実験的検証である．
本研究はシミュレーションのみによる評価であるため，
実際に合成DNAを用いたナノポアシーケンサーでの読み出し実験を行うことで，
提案手法の実用性を検証する必要がある．


%======================================================================
%		謝辞
%======================================================================
\begin{acknowledgements}
本研究を進めるにあたり，ご指導・ご助言を賜りました佐藤高史教授に
深く感謝申し上げます．
研究会やミーティングを通じて多くの貴重なご指摘・ご助言をいただきました
粟野皓光准教授，橋本昌宜教授，上野嶺准教授，白井僚助教，新津葵一教授，劉昆洋助教
に深く感謝致します．日々の研究において様々な助言をいただきました
小池健文氏に深く感謝いたします．
研究室生活において様々な面から支えて頂いた佐藤高史研究室支援職員の
西山修子氏，上西香織氏に感謝致します．
最後に，日頃から様々なご支援，ご協力を頂きました
佐藤研究室，橋本研究室，新津研究室の皆様に感謝致します．
\end{acknowledgements}



%======================================================================
%		参考文献
%======================================================================
\bibliographystyle{kueethesis}
\bibliography{reference}



%======================================================================
%		付録
%======================================================================
\appendix
\chapter{復号の探索効率化における予備実験}
\section{実験方法}
まず，ナノポアシーケンサーの出力特性を表す行列$\bm{P}_{STATS}$を得るため，
ランダムなバイナリデータをHEDGESで符号化した複数のDNA鎖に対し，
ナノポアシーケンサーによる電流波形をSquigulatorを用いて
シミュレーションした．
次に，シミュレーションされた電流波形に対してBonitoを用いて
CTC出力を取得し，\ref{ctc_output}節で述べた方法で$\bm{P}_{CTC}$を得た．
ここで，HEDGES符号化結果における$j$番目のDNA鎖の$i$番目の塩基を$C_i^{(j)}$と表し，
この塩基配列を$\{C_i^{(j)}\}$とする．また，
$\{C_i^{(j)}\}$のベースコールにおいて得られた
$\bm{P}_{CTC}$を$\bm{P}_{CTC}^{(j)}$と表すこととし，
$\bm{P}_{CTC}^{(j)}$の各行において，出力確率が最大となる塩基を選択することで
得られる塩基配列を$\{C'^{(j)}_i\}$と表す．この$\{C'^{(j)}_i\}$と$\{C_i^{(j)}\}$に対して
グローバルアラインメントを行い，各塩基ごとに
正しい読み出し，置換・挿入・消失エラーの発生数を集計した\cite{GOTOH1982705}．
これを全ての$j$について行い，集計することで
各事象の発生確率を計算し，行列$\bm{P}_{STATS}$を得た．

$\mu_{STATS\_ok}$，$\mu_{STATS\_sub}$，
$\mu_{STATS\_ins}$，$\mu_{STATS\_del}$はそれぞれ，正しい読み出し，置換エラー，
挿入エラー，消失エラー発生したときの$\bm{P}_{STATS}$のスコアの期待値であるから，
\begin{align}
  \mu_{STATS\_ok} &= \dfrac{\displaystyle \sum_{X \in \{A,C,G,T\}} p_{XX} \bm{P}_{STATS}(X,X)}{\displaystyle \sum_{X \in \{A,C,G,T\}} p_{XX}} \\
  \mu_{STATS\_sub} &= \dfrac{\displaystyle \sum_{X,Y \in \{A,C,G,T\}, X \neq Y} p_{XY} \bm{P}_{STATS}(X,Y)}{\displaystyle \sum_{X,Y \in \{A,C,G,T\}, X \neq Y} p_{XY}} \\
  \mu_{STATS\_ins} &= \dfrac{\displaystyle \sum_{Y \in \{A,C,G,T\}} p_{NY} \bm{P}_{STATS}(N,Y)}{\displaystyle \sum_{Y \in \{A,C,G,T\}} p_{NY}} \\
  \mu_{STATS\_del} &= \dfrac{\displaystyle \sum_{X \in \{A,C,G,T\}} p_{XN} \bm{P}_{STATS}(X,N)}{\displaystyle \sum_{X \in \{A,C,G,T\}} p_{XN}}
\end{align}
により計算される．
$\mu_{CTC\_ok}$，$\mu_{CTC\_sub}$，
$\mu_{CTC\_ins}$はそれぞれ，$\bm{P}_{CTC}$において
正しい読み出し，置換エラー，挿入エラーに対応するスコアの期待値であるから，
\begin{align}
  \mu_{CTC\_ok} &= \dfrac{1}{M}\sum_j \sum_i \bm{P}_{CTC}^{(j)}(i, C'^{(j)}_i) \\
  \mu_{CTC\_sub} &= \dfrac{1}{3M}\sum_j \sum_i \sum_{X \in \{A,C,G,T\}, X \neq C'^{(j)}_i} \bm{P}_{CTC}^{(j)}(i, X) \\
  \mu_{CTC\_ins} &= \dfrac{1}{M}\sum_j \sum_i \bm{P}_{CTC}^{(j)}(i, N)
\end{align}
により計算される．
ただし，$M$はベースコールされた全てのDNA鎖における塩基数の総和を表す．

次に，式\eqref{opt1}から\eqref{opt4}に示した
固定の報酬とペナルティ$P_{ok}, P_{sub}, P_{ins}, P_{del}$
及び各補正項の重み付けパラメータ
$\alpha_{ok}, \alpha_{sub}, \alpha_{ins}, \alpha_{del},
\beta_{ok}, \beta_{sub}, \beta_{ins}$の最適な値を決定する．
ここで，$P_{ok}$には\cite{HEDGES}の研究で用いられた値を各符号化率ごとに使用し，
$P_{ok}$以外のパラメータを最適化した．
各パラメータの最適化は，復号におけるヒープの探索数を目的関数とした，
数値微分を用いた勾配降下法により行った．
具体的には，まずランダムに生成したバイナリデータをHEDGESで符号化し，
ナノポアシーケンサーでの読み出しをシミュレーションした上で
その電流波形に対してベースコーラーを適用し，CTC出力を得た．
勾配降下法によるパラメータの最適化は，このCTC出力の復号を対象として，
以下の手順で行った．
\begin{enumerate}
  \item 最適化対象の各パラメータを適当な初期値で初期化する．
  \item 提案手法を用いて復号を実施し，復号が完了するまでのヒープの探索数を計測する．
  \item 各パラメータごとに微小な値$\Delta$を加えた場合の復号における
  ヒープの探索数を計測する．
  \item これらの値を用いて各パラメータに関する目的関数の勾配を計算する．
  \item 各パラメータを学習率$\eta$を用いて以下のように更新する．
  \begin{align}
    \bm{\theta} \leftarrow \bm{\theta} - \eta \dfrac{\partial J}{\partial \bm{\theta}}
  \end{align}
  ここで，$\theta$は最適化対象の各パラメータを表し，$J$は目的関数を表す．
  \item 2から5を一定回数繰り返す．
\end{enumerate}
パラメータの最適化については，ナノポアシーケンサーの読み出し特性に基づく補正項と
CTC出力に基づく補正項の両方を用いる場合と，それぞれ一方のみを用いる場合について
効果を検証するため，
$P_{sub}$,$P_{ins}$,$P_{del}$,$\alpha_{ok}$, $\alpha_{sub}$, $\alpha_{ins}$, $\alpha_{del}$,
$\beta_{ok}$, $\beta_{sub}$, $\beta_{ins}$の10個のパラメータに対して行うのに加えて，
$\alpha_{ok}=\alpha_{sub}=\alpha_{ins}=\alpha_{del}=0$として他の6個のパラメータに対してのみ
行う場合と
$\beta_{ok}=\beta_{sub}=\beta_{ins}=0$として他の7個のパラメータに対してのみ
行う場合についても実施した．
なお，これらの最適化は符号化率$0.75,0.60,0.50,0.33$について
それぞれ独立に行った．

\section{実験条件}
行列$\bm{P}_{STATS}$を得るためのシミュレーションでは，ランダムに生成した400KBのバイナリデータを
HEDGESで符号化率0.50で符号化した．各DNA鎖の塩基長は400ntとし，
合計12240本のDNA鎖を生成した．
Squigulatorによる電流値シミュレーションのパラメータ設定，
ベースコーラーのモデルについては\ref{sim1}節の実験と同様である．

ベースコーラーのファインチューニングには，
ランダムに生成した200KBのバイナリデータを
HEDGESで符号化率0.50，塩基長400ntで符号化して得られた6120本のDNA鎖と，
これらのDNA鎖に対してSquigulatorでシミュレーションした電流波形を学習データとして用いた．
既存の学習済みモデルである
dna\_r9.4.1@v2の重みを初期値として，バッチサイズを64として1エポックあたり75ステップ
の学習を行い，エポック数は50としてファインチューニングを行った．

$\{C^{(n)}_i\}$と$\{C'^{(n)}_i\}$に対するアラインメントにはBiopythonの
Gotohアルゴリズムを用いたグローバルアラインメントを使用した\cite{biopython,GOTOH1982705}．

パラメータの最適化では，ランダムに生成した400KBのバイナリデータを符号化率
$0.75,0.60,0.50,0.33$で塩基長を400ntとしてHEDGES符号化したものに対して
電流波形シミュレーション・ベースコールを行って得られたCTC出力を用いた．
$P_{ok}$は各符号化率ごとに表\ref{tab:fixed_reward}に示す固定の値を使用した．
各パラメータの初期値は$P_{sub}=P_{ins}=P_{del}=1.0$，
$\alpha_{ok}=\alpha_{sub}=\alpha_{ins}=\alpha_{del}=0.0$，
$\beta_{ok}=\beta_{sub}=\beta_{ins}=0.0$とした．
学習率は符号化率ごとに表\ref{tab:learning_rate}に示す値を使用し，パラメータの更新を300回繰り返した．
\begin{table}
  \centering
  \begin{minipage}{0.48\linewidth}
    \centering
    \caption{符号化率ごとの報酬値$P_{ok}$}
    \label{tab:fixed_reward}
    \begin{tabular}{c|c}
      符号化率 & $P_{ok}$ \\
      \hline
      0.75 & -0.035 \\
      0.60 & -0.082 \\
      0.50 & -0.127 \\
      0.33 & -0.229 \\
    \end{tabular}
  \end{minipage}
  \hfill
  \begin{minipage}{0.48\linewidth}
    \centering
    \caption{符号化率ごとの学習率$\eta$}
    \label{tab:learning_rate}
    \begin{tabular}{c|c}
      符号化率 & $\eta$ \\
      \hline
      0.75 & $1.3 \times 10^{-7}$ \\
      0.60 &  $4.1 \times 10^{-7}$\\
      0.50 &  $1.0 \times 10^{-6}$ \\
      0.33 &  $3.8 \times 10^{-6}$ \\
    \end{tabular}
  \end{minipage}
\end{table}
なお，$\bm{P}_{STATS}$を得るためのシミュレーション，
ベースコーラーのファインチューニング，
パラメータの最適化に用いたランダムなバイナリデータは全て独立に生成したものである．

\section{結果}
ナノポアシーケンサーの読み出し特性の評価において，
ラベル$\{N,A,C,G,T\}$間の遷移確率は表\ref{tab:transition_matrix}に
示すように得られた．
\begin{table}
  \centering
  \caption{ラベル間の遷移確率}
  \label{tab:transition_matrix}
  \begin{tabular}{c|ccccc}
    入力$\backslash$出力 & N & A & C & G & T \\
    \hline
    N & $0.000$ & $3.11 \times 10^{-4}$ & $3.11 \times 10^{-4}$ & $3.18 \times 10^{-4}$ & $3.86 \times 10^{-4}$  \\
    A & $9.28 \times 10^{-4}$ & $0.232$ & $5.03 \times 10^{-4}$ & $1.01 \times 10^{-3}$ & $3.94 \times 10^{-5}$ \\
    C & $5.95 \times 10^{-4}$ & $3.10 \times 10^{-4}$ & $0.244$ & $3.56 \times 10^{-4}$ & $1.27 \times 10^{-4}$ \\
    G & $8.27 \times 10^{-4}$ & $9.00 \times 10^{-4}$ & $6.60 \times 10^{-4}$ & $0.269$ & $5.13 \times 10^{-5}$ \\
    T & $6.73 \times 10^{-4}$ & $4.36 \times 10^{-5}$ & $1.55 \times 10^{-4}$ & $5.85 \times 10^{-5}$ & $0.247$ \\
  \end{tabular}
\end{table}
この結果では，正しい読み取りは全体のうち99.1\%を占めており，
置換エラーは0.421\%，挿入エラーは0.133\%，消失エラーは0.302\%であった．
また，置換エラーはA,G間とC,T間で発生しやすい傾向が見られ，
特に，最も確率の低いA,T間の
置換と比べてA,G間の置換は約23倍の確率で発生することが分かった．
塩基ごとの置換エラー発生率の偏りは，
プリン塩基(A,G)とピリミジン塩基(C,T)の化学構造
の類似性に起因すると考えられている\cite{10.1371/journal.pone.0257521}．
NからA,C,G,Tへの遷移で表わされる挿入エラーは，
各塩基に対して同程度の確率で発生していた．
A,C,G,TからNへの遷移で表わされる消失エラーは，
A,GにおいてC,Tよりも比較的高い確率で発生していた．
この結果から得られた行列$\bm{P}_{STATS}$は
式\eqref{eq:appendix_P_STATS}のようになった．
各補正項の期待値は表\ref{tab:appendix_mu_values}に示す．
各符号化率ごとに最適化されたペナルティと補正項の重み付けパラメータは
表\ref{tab:appendix_params_p}および表\ref{tab:appendix_params_alpha_beta}に示す．
\begin{align}
  \bm{P}_{STATS} =
  \begin{bmatrix}
    -1.20 & -0.650 & -0.650 & -0.643 & -0.613 \\
    -0.580 & 0.130 & -0.670 & -0.590 & -1.25 \\
    -0.620 & -0.650 & 0.110 & -0.640 & -1.09 \\
    -0.550 & -0.520 & -0.590 & 0.160 & -1.53 \\
    -0.590 & -1.53 & -1.09 & -1.25 & 0.120 \\
  \end{bmatrix} \label{eq:appendix_P_STATS}
\end{align}

\begin{table}
  \centering
  \caption{得られた各期待値}
  \label{tab:appendix_mu_values}
  \begin{tabular}{c|c}
    パラメータ & 値 \\
    \hline
    $\mu_{STATS\_ok}$ & 1.38 \\
    $\mu_{STATS\_sub}$ & 7.52 \\
    $\mu_{STATS\_ins}$ & 8.01 \\
    $\mu_{STATS\_del}$ & 7.17 \\
    $\mu_{CTC\_ok}$ & 0.111 \\
    $\mu_{CTC\_sub}$ & 6.85 \\
    $\mu_{CTC\_ins}$ & 2.78 \\
  \end{tabular}
\end{table}

\begin{table}
  \centering
  \caption{符号化率ごとに最適化したペナルティ}
  \label{tab:appendix_params_p}
  \footnotesize
  \begin{tabular}{c|c|ccc}
    符号化率 & 手法 & $P_{\text{sub}}$ & $P_{\text{ins}}$ & $P_{\text{del}}$ \\
    \hline
    \multirow{3}{*}{0.75} & STATSのみ$^{*}$ & 0.630 & 0.650 & 0.687 \\
    & CTCのみ$^{**}$ & 0.837 & 0.912 & 0.765 \\
    & STATS+CTC$^{***}$ & 0.875 & 0.911 & 0.778 \\
    \hline
    \multirow{3}{*}{0.60} & STATSのみ$^{*}$ & 0.883 & 0.965 & 0.995 \\
    & CTCのみ$^{**}$ & 0.856 & 1.06 & 0.890 \\
    & STATS+CTC$^{***}$ & 1.08 & 1.17 & 1.02 \\
    \hline
    \multirow{3}{*}{0.50} & STATSのみ$^{*}$ & 0.988 & 1.17 & 1.25 \\
    & CTCのみ$^{**}$ & 0.953 & 1.11 & 1.04 \\
    & STATS+CTC$^{***}$ & 1.15 & 1.23 & 1.19 \\
    \hline
    \multirow{3}{*}{0.33} & STATSのみ$^{*}$ & 1.07 & 1.25 & 1.39 \\
    & CTCのみ$^{**}$ & 1.06 & 1.22 & 1.21 \\
    & STATS+CTC$^{***}$ & 1.29 & 1.35 & 1.34 \\
  \end{tabular}
  
  \small
  \vspace{0.3cm}
  
  \noindent
  \begin{tabular}{@{}l@{}}
    $^{*}$STATSのみ: ナノポアシーケンサーの読み出し特性に基づく補正項のみを使用 \\
    $^{**}$CTCのみ: CTC出力に基づく補正項のみを使用 \\
    $^{***}$STATS+CTC: ナノポアシーケンサーの読み出し特性およびCTC出力の両方に基づく補正項を使用
  \end{tabular}
\end{table}

\begin{table}
  \centering
  \caption{符号化率ごとに最適化した補正項の重み付けパラメータ}
  \label{tab:appendix_params_alpha_beta}
  \footnotesize
  \begin{tabular}{c|c|cccc|ccc}
    符号化率 & 手法 & $\alpha_{\text{ok}}$ & $\alpha_{\text{sub}}$ & $\alpha_{\text{del}}$ & $\alpha_{\text{ins}}$ & $\beta_{\text{ok}}$ & $\beta_{\text{sub}}$ & $\beta_{\text{ins}}$ \\
    \hline
    \multirow{3}{*}{0.75} & STATSのみ& 0.0605 & 0.116 & 0.0929 & 0.0952 & 0.00 & 0.00 & 0.00 \\
    & CTCのみ& 0.00 & 0.00 & 0.00 & 0.00 & -0.192 & 0.211 & 0.347 \\
    & STATS+CTC& 0.00668 & 0.130 & -0.0105 & 0.544 & -0.150 & 0.181 & 0.301 \\
    \hline
    \multirow{3}{*}{0.60} & STATSのみ & 0.00513 & 0.256 & 0.200 & 0.0969 & 0.00 & 0.00 & 0.00 \\
    & CTCのみ & 0.00 & 0.00 & 0.00 & 0.00 & -0.223 & 0.190 & 0.419 \\
    & STATS+CTC & 0.110 & 0.243 & 0.236 & 0.219 & -0.115 & 0.184 & 0.330 \\
    \hline
    \multirow{3}{*}{0.50} & STATSのみ & 0.0548 & 0.294 & 0.0800 & 0.0871 & 0.00 & 0.00 & 0.00 \\
    & CTCのみ & 0.00 & 0.00 & 0.00 & 0.00 & -0.108 & 0.193 & 0.411 \\
    & STATS+CTC & 0.131 & 0.292 & 0.234 & 0.176 & -0.136 & 0.188 & 0.467 \\
    \hline
    \multirow{3}{*}{0.33} & STATSのみ & -0.00773 & 0.282 & 0.167 & 0.246 & 0.00 & 0.00 & 0.00 \\
    & CTCのみ & 0.00 & 0.00 & 0.00 & 0.00 & 0.0272 & 0.145 & 0.422 \\
    & STATS+CTC & 0.0260 & 0.328 & 0.177 & 0.230 & 0.0417 & 0.134 & 0.460 \
  \end{tabular}
\end{table}


\end{document}
% Local Variables:
% fill-column: 70
% End:

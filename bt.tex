\documentclass[sotsuron]{kuee}

\usepackage[dvipdfmx]{graphicx}
\usepackage{here}
\usepackage{amsmath}
\usepackage{bm}
\usepackage{multirow}


\title{DNAストレージにおけるナノポアシーケンサーの読み出し特性を考慮した誤り訂正手法}
\etitle{Error Correction Method Considering the Reading Characteristics of Nanopore Sequencers in DNA Storage}
\author{岩瀬 真太郎}
\eauthor{Shintaro Iwase}
\professor{佐藤 高史 教授}
% \course{京都大学大学院情報学研究科}
% \department{知能情報学専攻}
\date{令和8年2月10日}

%%% 本文
\begin{document}
\maketitle			% 表題を出力
\begin{eabstract}		% 英文要旨を出力
This document briefly explains the usage of the \LaTeX{} style file
for KUEE bacheler thesis and master thesis.
\end{eabstract}
\tableofcontents		% 目次を出力

\chapter{序論}
情報化社会が進展した現代では，日々大量のデジタルデータが生成されており，
世界中のデータ量は爆発的に増加し続けている．
2025年の報告では
全世界のデジタルデータ量は173.4ゼタバイトにのぼると推定され，
2029年には527.5ゼタバイトに達すると予測されている\cite{statista_worldwide_data_created}．
これらの大量のデータのうち，約60\%はアクセス頻度の極めて低いコールドデータであることが
知られている\cite{dna_data_storage_alliance_2021_intro}．
コールドデータの中には，法令に基づき長期間保存が義務付けられているものや，
将来的に解析される可能性のある研究データなどが含まれており，
これらを消去することは困難である．
そのため，コールドデータを安価で長期間保存できるアーカイブストレージ技術が
求められている\cite{reinsel2017dataage2025,dna_data_storage_alliance_2021_intro}．

%導入 背景 DNAストレージ
近年，次世代のアーカイブストレージ技術としてDNAストレージが注目されている．
DNAストレージとは，デジタルデータをDNAの4種類の塩基配列（A，C，G，T）に符号化し，
人工的に合成したDNA分子にデータを保存する技術である．
DNAストレージは，適切な保存環境下であれば数千年以上にわたりデータを保存することが可能な
高い耐久性を持つことに加えて，
体積あたりに保存可能な情報量が非常に大きいため
高い情報密度を実現できることが見込まれており，
コールドデータの保存に適した新たなストレージ技術として期待されている
\cite{akash2024_applicable,Ceze2019,dna_data_storage_alliance_2021_intro}．

%DNAストレージ シーケンサ
DNAストレージにおけるデータの読み出しでは，DNAシーケンサーを用いてDNA分子の塩基配列を
解析する\cite{Ceze2019}．
DNAシーケンサーは数十から数百bp
\footnote{base pair(塩基対) の略．2本鎖DNAの塩基配列長を表す単位．
1本鎖の場合はnucleotidesからntという単位を用いる．}
の比較的短いDNAを対象とした
ショートリードシーケンサー\cite{Simon2009}と，
数百から数万bpの比較的長いDNAを対象としたロングリードシーケンサー\cite{Amarasinghe2020}に大別されるが，
DNAストレージに関する現在までの多くの研究では，
SBS(Sequence By Synthesis)法\cite{SBS}と呼ばれる
技術を用いたショートリードシーケンサーが主に用いられてきた．
SBS法は同時に大量のDNA断片を高精度で解析することができるという利点があるが，
一度に解析できるDNAの塩基長が数百bp程度と短いことや，解析速度が遅いという欠点がある\cite{SBS}．
一方，ロングリードシーケンサーの一つであるナノポアシーケンサーは
一度に数十万bp程度の長いDNAを高速に解析することが出来るため，
DNAストレージの読み出し用のシーケンサーとして実用的であると考えられる\cite{Amarasinghe2020}．
そこで，本研究ではナノポアシーケンサーを用いたDNAストレージに着目する．

ナノポアシーケンサーは高速で長い塩基長のDNAを解析できる一方で，
SBS法に比べて塩基配列の決定精度が低いことが知られており，
特に挿入・消失エラーが多いことが課題となっている\cite{Amarasinghe2020,Dorey2024}． 
そのため，DNAストレージにおいてナノポアシーケンサーを用いる場合，
置換・挿入・消失エラーに対応した誤り訂正符号の検討が重要である．

先行研究では，同一塩基の一定以上の連続(ホモポリマー)の禁止や
グアニン・シトシン(GC)の含有率に関する制限といったシーケンス制約を
満たしつつ，置換・挿入・消失エラーに対応可能なDNAストレージ向けの誤り訂正符号を提案し，
シミュレーションと実際に合成DNAを用いた実験により，
最大10\%程度の誤りを含む塩基配列からペタバイト規模のデータを
正確に復元できる可能性を示した\cite{HEDGES}．
しかし，先行研究はDNAストレージの読み出しにはショートリードシーケンサーを用いることを前提としており，
ナノポアシーケンサーの読み出し特性を考慮した誤り訂正符号の検討は十分に行われていない．
また，先行研究の提案手法では長い塩基長では復号精度が低下することが知られており，
ナノポアシーケンサーのようなロングリードシーケンサーを用いて
長い塩基長を扱う場合の復号精度の向上も課題である．

本研究では，DNAストレージの読み出しにおいてナノポアシーケンサーを用いることを
前提とした誤り訂正手法を提案する．
既存の誤り訂正手法における復号アルゴリズムにおいて，
ナノポアシーケンサーの読み出し特性を考慮した最適化を行い，
復号処理の効率化と精度の向上を図る．
また，符号化プロセスにおいても長い塩基長のDNAを扱う際の精度の低下を
抑制するための手法を提案する．
提案手法に対してバイナリデータの符号化から
ナノポアシーケンサーを用いた読み出し，復号までの一連のプロセスに関する
シミュレーションを行い，その性能を評価する．

\chapter{DNAストレージの符号化・読み出しプロセス}
% 本章では，ナノポアシーケンサーによる遺伝子解析技術の概要と，
% DNAストレージにおける誤り訂正符号の一つであるHEDGES符号化・復号の概要について説明する．
% また，既存手法における課題と本研究の目的を述べる．

\section{ナノポアシーケンサーとBasecaller} \label{nanopore}
ナノポアシーケンサーはDNAが溶液中で帯電していることを利用して，
電気泳動現象によりDNAをナノポアと呼ばれるタンパク質の細孔に通過させることで
DNAの塩基配列を解析するシーケンサーである\cite{Amarasinghe2020,Dorey2024}．
ナノポアシーケンサーのフローセル内の膜の上には複数のナノポアタンパク質が配置されており，
その細孔の直径は約1nmで，1本のDNAのみが通過できる大きさになっている．
フローセルは塩化カリウムを含んだ電解質で満たされており，溶液中で
DNAは負に帯電しているため，電圧をかけることで電気泳動により電場の方向に移動する．
これによりDNAの進行方向を制御し，ナノポアを通過させる．
ナノポアを通過するDNAはヘリカーゼと呼ばれる酵素によって2本鎖DNAから1本鎖DNAに解かれつつ，
一定の速度で通過するように制御されている．
このとき，ナノポアを通過するDNAがナノポア内のイオンの流れを阻害するため，イオン電流の大きさが
変化する．
イオン電流の変化は，ナノポアを通過中の塩基の並びによって異なるため，
電流の変化を解析することでDNAの塩基配列を決定することができる．
\begin{figure}
    \begin{center}
        \includegraphics[width=150mm]{nanopore.png}
        \caption{ナノポアシーケンサーの原理と手順}\label{fig:nanopore}
    \end{center}
\end{figure}

電流信号から塩基配列を決定するプロセスはBasecallと呼ばれ，Basecallerと呼ばれる
機械学習モデルによって行われる．Basecallerはナノポアシーケンサーを開発している
Oxford Nanopore Technologies(ONT)社からいくつかのバージョンが公開されているが，
本研究で使用するBonitoと呼ばれるBasecallerのアーキテクチャの概要を図\ref{fig:bonito}に示す\cite{bonito}．
Bonitoでは，まず入力された電流信号に対して畳み込みニューラルネットワーク(CNN)を適用し，
特徴量を抽出する．次に，LSTMを用いて電流信号の長距離の依存関係を捉え，
時系列データとしての特徴を抽出する．
その後，CTC出力層でLSTM出力に線形層を適用し，blankと4種類の塩基からなる
ラベル集合(N，A，C，G，T)に対するスコア系列を出力する．
このスコア系列に対してビームサーチを用いて最終的な塩基配列を決定する．
このとき，ラベル列に対してCollapseと呼ばれる以下の処理を適用する．
\begin{enumerate}
  \item 連続する同一ラベルを1つにまとめる．
  \item blankラベル(N)を削除する．
\end{enumerate}
これにより，例えばラベル列``AANNCCGNGGGTT''は
``ACGGT''に変換される．
\begin{figure}
    \begin{center}
        \includegraphics[width=150mm]{architecture.png}
        \caption{Bonito Basecallerのアーキテクチャ概要}\label{fig:bonito}
    \end{center}
\end{figure}

DNAストレージの読み出しにナノポアシーケンサーを採用する利点としては
以下のような点が挙げられる\cite{Amarasinghe2020,Dorey2024,SBS}．
\begin{itemize}
  \item SBS法では一度に解析できるDNAの塩基長が数十bpから数百bpと短く，長いDNAは
  複数の断片に分割して解析する必要があるのに対し，ナノポアシーケンサーは一度に数百bpから数百万bpの
  長いDNAを直接的に解析することが出来る．
  \item SBS法では解析に数日から数週間を要するのに対し，ナノポアシーケンサーは400bp/s
  での高速な解析が可能である．
  \item ナノポアシーケンサーはリアルタイムでの解析が可能であり，解析するサンプルを
  柔軟に制御できるため，必要なデータを効率的に取り出すことが出来る．
  \item 小型で低コストな装置であるため，設置場所の制約が少なく，運用コストが低い．
\end{itemize}
一方で，ナノポアシーケンサーはヘリカーゼを用いたDNAの進行速度の制御が難しく，
Basecallerでの塩基配列の推論が正確に行われない場合がある．
そのため，ナノポアシーケンサーはSBS法に比べて読み取り精度が低いことが知られており，
ナノポアシーケンサーを用いたDNAストレージでは，誤り訂正符号の検討が特に重要である\cite{Amarasinghe2020,Dorey2024}．

\section{HEDGES符号化} \label{hedges_encoding}
DNAストレージにおける符号化では，DNA合成時のエラーの抑制や構造安定性の確保のために
シーケンス制約が課される．シーケンス制約には一定以上の同一塩基の連続(ホモポリマー)の禁止や
グアニン・シトシン(GC)含有率が一定範囲内に収まるようにする制約がある\cite{Gervasio}．
また，復号の際に発生するエラーの訂正を考慮した冗長性を付加することに加えて，
シーケンスの際に発生するエラーに対しての耐性を持たせる必要がある．
シーケンス時に発生するエラーには以下の3種類がある．
\begin{itemize}
  \item 置換エラー(substitution): 読み出された塩基が本来の塩基とは異なる場合．
  \item 挿入エラー(insertion): 本来の塩基配列に存在しない塩基が読み出された場合．
  \item 消失エラー(deletion): 本来の塩基配列に存在する塩基が読み出されなかった場合．
\end{itemize}

HEDGES(Hash Encoded, Decoded by Greedy Exhaustive Search)は，シーケンス制約を満たしつつ，
置換・挿入・消失エラーに対応可能な誤り訂正手法である\cite{HEDGES}．
HEDGESではデータをパケット単位で扱う．
各パケットは255本の固定長DNAストランドからなり，ストランドの塩基長は自由に設定できるが，
通常は数百nt程度が選ばれる．
符号化の際はまずバイナリデータをパケット単位に分割し，
各パケットのビット列に対してリード・ソロモン(RS)符号化を適用する．
このRS符号は外部符号と呼び，塩基配列からビット列への復号の際に発生したエラーを
最終的に訂正する役割を持つ．
次に，RS符号化を適用したビット列に対して内部符号であるHEDGES符号化を適用し，
塩基配列を生成する．
HEDGESはビット列から塩基配列への変換において，符号化率が可変である
という特徴を持つ．
DNAの塩基は4種類あるため，1塩基あたり最大2ビットまで割り当てることが出来るが，
この場合，符号化率は$r=1$であり冗長性がないため，誤り訂正能力を持たない．
符号化率を下げることで冗長性を付加し，誤り訂正能力を持たせることが出来る．

ビット列から塩基配列の変換においては，ここでは符号化率$r=0.5$，
すなわち1ビットを1塩基に対応させる場合の符号化手法について説明し，
その後に他の符号化率への拡張方法について述べる．

メッセージのビット列$\{b_i\}$が以下のように与えられたとする．
\begin{align}
  b_i, \quad i=0,1,2,\ldots M, \quad b_i \in \{0,1\}
\end{align}
符号化率$r=0.5$では，
各ビット$b_i$に対して塩基$C_i$を割り当てればよい．
\begin{align}
  C_i, \quad i=0,1,2,\ldots M, \quad C_i \in \{C_i^*\}
\end{align}
ここで，$\{C_i^*\}$はシーケンス制約を満たすために$C_i$として許される塩基の候補集合である．
$\{C_i^*\}$の各塩基には0から順に整数値が割り当てられているとする．
このとき，$i$番目の塩基$C_i$は以下の式で与えられる．
\begin{align}
  K_i &= F\left( S_i, I_i, B_i \right) \\
  C_i &=  K_i + b_i  \quad \left(\rm{mod} \#C_i^*\right) \label{encode_half}
\end{align}
ここで，$F$はハッシュ関数であり，$S_i$はストランドIDに基づくソルト，
$I_i$はビット位置のインデックス，$B_i$は直前の12ビット分の値である．
また，$\#C_i^*$は$\{C_i^*\}$の要素数を表す．
すなわち，各ビットに対応する塩基は，ストランドID，ビット位置，直前のビット列に基づく
ハッシュ関数の値を目的のビットに加算し，出力塩基の候補数で剰余をとることにより，
擬似ランダムかつ一意に決定される．

$r=0.5$以外の符号化率を用いる場合も基本的な考え方は同様である．$r=0.5$の場合は
1塩基に1ビットを対応させたが，他の符号化率を実現するには，各塩基へ割り当てる
ビット数を0ビットから2ビットの範囲で規則的に変化させる．
つまり，一般には出力塩基$C_i$に対応するものはビット$b_i$ではなく，0から2の長さを持つ
ビット列$v_i$となる．
以下に，符号化率$r=0.750$の場合と$r=0.333$の場合の$v_i$の構成例を示す．
\begin{align}
  r=0.750&: \quad v_0 = b_0b_1, \quad v_1 = b_2, \quad v_2 = b_3b_4, \quad v_3 = b_5, \quad v_4 = b_6b_7, \ldots \label{eq1} \\
  r=0.333&: \quad v_0 = b_0, \quad v_1 = b_1, \quad v_2 = 0, \quad v_3 = b_2, \quad v_4 = b_3, \quad v_5 = 0, \ldots
\end{align}
ただし，式\eqref{eq1}において隣接するビットは2ビットの値を表している．
$r=0.750$では塩基へビット割り当て数は2ビットと1ビットが交互に繰り返され，
$r=0.333$では，塩基へのビット割り当て数は1ビット，1ビット，0ビットの順に繰り返される．
したがって，各ビット列$v_i$に対応する出力塩基を決定する式は，式\eqref{encode_half}の
$b_i$を$v_i$に置き換えたものとなり，以下のように表される．
\begin{align}
  C_i = K_i + v_i = F( S_i, I_i, B_i ) + v_i \quad \left(\rm{mod} \#C_i^*\right) \label{encode}
\end{align}

HEDGESでエンコードするビット列の先頭はストランドIDを表すビット列であり，
ID部分の符号化では$S_i=0$とされる．ビット列を符号化して得られた塩基配列の
両端にはプライマーと呼ばれる決められた塩基配列を付加され，最終的なDNAストランドの出力
となる．

\section{HEDGES復号} \label{hedges_decoding}
HEDGESでは置換・挿入，消失エラーを含む塩基配列から元のビット列を復元するために，
Greedy Exhaustive Search(貪欲探索法)に基づく復号アルゴリズムを用いる\cite{Astar}．
復号アルゴリズムでは，まず入力された塩基$C'_i$に対応するビット列$v_i$の各候補について仮説を立てる．
各仮説において式\eqref{encode}を用いて予測される塩基$C_i$と，実際に入力された塩基$C'_i$を比較し，
一致していればスコアに報酬(負の値)を加算し，不一致であればペナルティ(正の値)を加算する．
仮説は各ステップにおいてスコアが最小となるものを選択し，これを親仮説として次の仮説を
展開していくことで，ヒープ構造を構築する．
さらに，挿入・消失エラーを考慮するために，各仮説では$v_i$だけではなく，
$\Delta \in \{-1, 0, 1\}$で表されるskewと呼ばれるパラメータも同時に仮定する．
skewは参照塩基を現在の位置からどれだけずらすかを表し，skewの値によってステップごとの
ペナルティ$\Delta P$は，
報酬$P_{ok}$，
置換ペナルティ$P_{sub}$，
挿入ペナルティ$P_{ins}$，
消去ペナルティ$P_{del}$
を用いて
以下のように計算される．
\begin{itemize}
  \item $\Delta = 0$の場合: \\ 位置ずれはなく，一致または置換エラーを表す．
  \begin{align}
    \Delta P = \begin{cases}
      P_{ok} & (\text{一致の場合}) \\
      P_{sub} & (\text{不一致の場合})
    \end{cases}
  \end{align}
  \item $\Delta = -1$の場合:\\ 消失エラーを仮定するため，入力塩基の参照位置を一つ戻す．
  この場合は参照する塩基がないので比較は行われない． 
  \begin{align}
    \Delta P = P_{del}
  \end{align}
  \item $\Delta = 1$の場合: \\ 1塩基の挿入エラーを仮定するため，入力塩基の参照位置を一つ進める．
  \begin{align}
    \Delta P = \begin{cases}
      P_{ins} + P_{ok} & (\text{一致の場合}) \\
      P_{ins} + P_{sub} & (\text{不一致の場合})
    \end{cases}
  \end{align}
\end{itemize}
各仮説のスコアは，親仮説のスコアに$\Delta P$を加算することで蓄積されていく．
そのため，仮説に誤りがある場合，後続の仮説のペナルティは急速に蓄積される特性がある．
これにより，正しい復号経路は他の経路に比べて顕著に低いスコアを持つようになり，
効率的に正しい復号経路を見つけることができる．
ただし，メッセージの末尾の数バイトでは，誤った仮説に対するペナルティが蓄積されるのに十分な
後続の塩基がないため，復号精度が低下する．これに対処するため，符号化時にメッセージ末尾に
2バイト分のrunoutと呼ばれるゼロパディングを追加し，復号時にはこれを除去する処理が行われる．

復号におけるヒープ探索処理では，計算の複雑性が爆発的に増加することを防ぐために，
ヒープサイズに上限を設け，上限に達した時点でデコードの失敗を宣言して探索を中止し，
ストランドの残りの部分をビット消失としてマークする．
復号失敗によるビット消失は外部符号であるRS符号によって最終的に訂正される．

\section{既存手法の課題と研究目的} \label{sec:problem}
\cite{HEDGES}の研究における課題点としては，以下の点が挙げられる．
\begin{itemize}
  \item 既存のHEDGES復号アルゴリズムにおいて，置換・挿入・消失エラーに対する
  ペナルティ$P_{sub}$，$P_{ins}$，$P_{del}$の値は概念的には各エラーの発生確率の負の対数
  であるとされているが，先行研究のシミュレーション評価においては，各エラーが等しい確率で
  発生する場合を想定して$P_{sub} = P_{ins} = P_{del}=1$と設定した上で，
  いくつかの符号化率において最適な報酬$P_{ok}$の値を経験的に決定するにとどめられており，
  実際にナノポアシーケンサーを用いて塩基の読み出しを行う場合の詳細な出力特性に基づいた
  報酬とペナルティの最適化については検討されていない．
  \item 既存のHEDGES復号アルゴリズムにおける入力は塩基配列であるため，
  各時点における塩基の出力確率分布を考慮した復号は行われない．
  \item 既存のHEDGES符号化・復号手法では，ヒープサイズの上限に達した場合に
  復号失敗としてその後のビット列をすべて消失として扱うため，長い塩基配列では
  復号失敗の発生率が高くなり，復号精度が低下する．
\end{itemize}
本研究では，DNAストレージの読み出しにおいてナノポアシーケンサーを
用いることを前提とした誤り訂正手法を提案する．
HEDGES復号アルゴリズムにおける報酬とペナルティに関して，
ナノポアシーケンサーで塩基の読み出しを行う場合の
各塩基のエラーの発生確率や遷移確率といった統計的な読み出し特性を考慮した最適化を行う．
また，Basecallerによって出力される各塩基の確率分布も報酬とペナルティに反映させることにより，
復号における探索数の削減と精度の向上を図る．
さらに，符号化プロセスにおいても長い塩基長のDNAを扱う際の精度の低下を
抑制するための手法を提案する．
これらの提案手法に対してシミュレーションを実施し，その性能を評価する．

\chapter{提案手法}\label{proposed_method}
\section{復号の探索効率化} \label{optimization}
本節では，復号における探索の効率化を図るために，
ナノポアシーケンサーの統計的な読み出し特性とBasecaller出力における
各時点での塩基の確率分布を考慮した報酬とペナルティの最適化手法を提案する．
まず，ナノポアシーケンサーの読み出し特性のモデル化と，Basecallerにおける
CTC出力の扱いについて説明し，その後にこれらを報酬とペナルティに反映させる手法について述べる．

\subsection{ナノポアシーケンサーの読み出し特性のモデル化} \label{stat_model}
塩基配列の読み出しにおいて，読み出し後の塩基配列と本来の塩基配列が分かっているとき，
シーケンスアライメントと呼ばれる手法を用いてこの2つの塩基配列を比較し，
一致部分や各種エラーの発生箇所を特定することができる
\cite{GOTOH1982705}．
アラインメントされた2つの塩基配列において，対応する塩基のペアが一致している場合は正しい
読み出しを表し，不一致の場合は置換エラーを表す．また，一方の配列の塩基が他方の配列の空白
に対応している場合は挿入・消失エラーを表す．
このようにして得られるアラインメント情報から，
DNA読み出しにおける正しい読み出しと
置換・挿入・消失エラーの発生という各事象は
4種類の塩基に空白(N)を含めた$\{N,A, C, G, T\}$の5種類のラベル間の
遷移として表すことができる．

これを用いてナノポアシーケンサーの統計的な読み出し特性を以下の行列$\bm{T}$で表す．
\begin{align}
  \bm{T} = \begin{bmatrix}
    0 & p_{AN} & p_{CN} & p_{GN} & p_{TN} \\
    p_{NA} & p_{AA} & p_{CA} & p_{GA} & p_{TA} \\
    p_{NC} & p_{AC} & p_{CC} & p_{GC} & p_{TC} \\
    p_{NG} & p_{AG} & p_{CG} & p_{GG} & p_{TG} \\
    p_{NT} & p_{AT} & p_{CT} & p_{GT} & p_{TT} \\
  \end{bmatrix}
\end{align}
この行列の各要素は，4種類の塩基が等しい割合で含まれる十分に長いDNA配列を
ナノポアシーケンサーで読み出す場合における，正しい読み出し，置換・挿入・消失エラーの
発生確率を
表し，$X,Y \in \{A,C,G,T\}$に対して
\begin{itemize}
  \item $p_{XX}$: 塩基Xが正しく読み出される確率
  \item $p_{XY}$: 塩基Xが塩基Yに置換される確率
  \item $p_{XN}$: 塩基Xが消失する確率
  \item $p_{NY}$: 塩基Yが挿入される確率
\end{itemize}
を表す．$\bm{T}$の全要素の和は1になる．
この行列$\bm{T}$の第1行第1列以外の各要素に対して自然対数をとって$-1$を乗じた行列
を$\bm{P}_{STATS}$とおき，後述の手法により報酬とペナルティの算出に利用する．

\subsection{CTC出力の扱い} \label{ctc_output}
\ref{nanopore}節で説明したように，Basecallerは通常，CTC出力に対して
ビームサーチを用いて最終的に塩基配列を出力するが，本研究の提案手法では
Basecallerでは塩基配列の決定までは行わず，CTC出力のスコア系列を直接出力する．
また，\ref{hedges_decoding}節で説明したように，既存のHEDGES復号アルゴリズムでは
塩基配列を入力とするが，提案手法ではCTC出力のスコア系列を
入力として利用する(図\ref{fig:optim})．これにより，各時点における出力塩基の確率分布を
復号アルゴリズムに反映させることができる．
\begin{figure}
    \begin{center}
        \includegraphics[width=150mm]{optim.png}
        \caption{提案手法の概要}\label{fig:optim}
    \end{center}
\end{figure}

CTC出力が$N\times 5$行列$\bm{S}$で与えられるとする．ここで，$N$は入力電流信号の長さに依存する
時系列長であり，各行は各時点における5種類のラベル$\{N,A,C,G,T\}$に対する
出力確率を表す．$\bm{S}$に対して，\ref{nanopore}節で説明したCollapseに相当する
以下の処理を適用して$\bm{S}'$を得る．
\begin{enumerate}
  \item $\bm{S}$において出力確率が最大となるラベルが連続している複数行に対し，
  各ラベルの確率の平均をとり，1行にまとめた行列を$\bm{S}'$とする．
  \item $\bm{S}'$から，blankラベル(N)に対する確率が最大となっている行を削除する．
\end{enumerate}
これにより得られた行列$\bm{S}'$の各行で確率が最大となる塩基を選択することで
得られる塩基配列は，通常のBasecallerの最終層でのビームサーチにおいてビーム幅を1と
した場合のBasecall結果に相当する．
$\bm{S}'$の各要素に対して自然対数をとって$-1$を乗じた行列を$\bm{P}_{CTC}$とおく．
$\bm{P}_{CTC}$の各列の要素は，各時点において各塩基またはblankが出力される
確率に基づくスコアを表す．
\ref{hedges_decoding}節で説明したように，
既存のHEDGES復号アルゴリズムでは，仮説から式\eqref{encode}を用いて予測される塩基と
対応する入力塩基を比較して，一致・不一致により報酬やペナルティを決定するが，
提案手法では，仮説から予測される塩基に対する出力確率に基づくスコアを
$\bm{P}_{CTC}$から取得し，これを用いて報酬やペナルティを決定する．

\subsection{報酬とペナルティの最適化} \label{reward_penalty_optimization}
既存手法では，報酬$P_{ok}$と置換・挿入・消失エラーに対する
ペナルティ$P_{sub}$，$P_{ins}$，$P_{del}$は一定値を用いるが，本研究では
\ref{stat_model}節および\ref{ctc_output}節で述べたナノポアシーケンサーの読み出し特性と
BasecallerのCTC出力を考慮した新しい報酬$P'_{ok}$と
ペナルティ$P'_{sub}$，$P'_{ins}$，$P'_{del}$を提案し，以下のように定義する．
\begin{equation}
  \begin{split}
    P'_{ok} = P_{ok} &+ \alpha_{ok}(\bm{P}_{STATS}[x_{hypo}, x_{max}[i]]-\mu_{STATS\_ok}) \label{opt1} \\ 
   &+ \beta_{ok}(\bm{P}_{CTC}[i, x_{hypo}]-\mu_{CTC\_ok}) 
  \end{split}
\end{equation}
\begin{equation}
  \begin{split}
    P'_{sub} = P_{sub} &+ \alpha_{sub}(\bm{P}_{STATS}[x_{hypo}, x_{max}[i]]-\mu_{STATS\_sub}) \label{opt2} \\
    &+ \beta_{sub}(\bm{P}_{CTC}[i, x_{hypo}]-\mu_{CTC\_sub})
  \end{split}
\end{equation}
\begin{equation}
  \begin{split}
    P'_{ins} = P_{ins} &+ \alpha_{ins}(\bm{P}_{STATS}[N, x_{max}[i-1]]-\mu_{STATS\_ins}) \label{opt3}\\
    &+ \beta_{ins}(\bm{P}_{CTC}[i-1, x_{hypo}]-\mu_{CTC\_ins})
  \end{split}
\end{equation}
\begin{equation}
  \begin{split}
    P'_{del} = P_{del} &+ \alpha_{del}(\bm{P}_{STATS}[x_{hypo}, N]-\mu_{STATS\_del}) \label{opt4}
  \end{split}
\end{equation}
ここで，$x_{hypo}$は仮説のビット列から出力される塩基を表し，$i$は仮説が参照する
$\bm{P}_{CTC}$の行番号を表す．また，$x_{max}[i]$は$\bm{P}_{CTC}$の$i$行目において
出力確率が最大となる塩基を表す．$\bm{P}_{STATS}[X,Y]\quad(x,y\in \{N,A,C,G,T\})$は$\bm{P}_{STATS}$における
ラベル$x$からラベル$y$への遷移に対応するスコアを表す．
$\bm{P}_{CTC}[i,X]$は，$\bm{P}_{CTC}$の$i$行目におけるラベル$X$のスコアを表す．
$\mu_{STATS\_ok}$，$\mu_{STATS\_sub}$，
$\mu_{STATS\_ins}$，$\mu_{STATS\_del}$はそれぞれ，正しい読み出し，置換エラー，
挿入エラー，消失エラー発生したときの$\bm{P}_{STATS}$のスコアの期待値を表し，
% すなわち
% \begin{align}
%   \mu_{STATS\_ok} &= \dfrac{\displaystyle \sum_{X \in \{A,C,G,T\}} p_{XX} \bm{P}_{STATS}[X,X]}{\displaystyle \sum_{X \in \{A,C,G,T\}} p_{XX}} \\
%   \mu_{STATS\_sub} &= \dfrac{\displaystyle \sum_{X,Y \in \{A,C,G,T\}, X \neq Y} p_{XY} \bm{P}_{STATS}[X,Y]}{\displaystyle \sum_{X,Y \in \{A,C,G,T\}, X \neq Y} p_{XY}} \\
%   \mu_{STATS\_ins} &= \dfrac{\displaystyle \sum_{Y \in \{A,C,G,T\}} p_{NY} \bm{P}_{STATS}[N,Y]}{\displaystyle \sum_{Y \in \{A,C,G,T\}} p_{NY}} \\
%   \mu_{STATS\_del} &= \dfrac{\displaystyle \sum_{X \in \{A,C,G,T\}} p_{XN} \bm{P}_{STATS}[X,N]}{\displaystyle \sum_{X \in \{A,C,G,T\}} p_{XN}}
% \end{align}
% である．
$\mu_{CTC\_ok}$，$\mu_{CTC\_sub}$，
$\mu_{CTC\_ins}$はそれぞれ，$\bm{P}_{CTC}$において
正しい読み出し，置換エラー，挿入エラーに対応するスコアの統計的な期待値を表す．
報酬と各ペナルティは，固定の値$P_{ok}$，$P_{sub}$，$P_{ins}$，$P_{del}$に対して，
期待値が0になるように正規化された補正項を加算することで計算される．
各補正項には，調整用のパラメータ$\alpha_{ok}$，$\alpha_{sub}$，$\alpha_{ins}$，$\alpha_{del}$，
$\beta_{ok}$，$\beta_{sub}$，$\beta_{ins}$が乗じられており，
シミュレーションにより固定のペナルティと各補正項の重み付けを最適化する．
各定数の設定方法やパラメータの最適化手法については\ref{simulation}で詳しく述べる．
% まず，仮説のビット列から出力される塩基を$x_{hypo}$とする．
% また，仮説が参照する$\bm{P}_{CTC}$の行番号を$i$とする．
% このとき，$\bm{P}_{CTC}$の$i$行目において出力確率が最大となる塩基を
% $x_{max}[i]$とする．

\section{ロングリードに向けた符号化アルゴリズムの改良} \label{long_read_encoding}
\ref{sec:problem}節で述べたように，既存のHEDGES符号化・復号手法では
ストランドを長くすると復号精度が低下することが知られている．
これは，復号アルゴリズムにおいて仮説数がヒープサイズの上限に達した場合に
復号失敗としてその後のビット列をすべて消失として扱うため，
塩基長が大きくなるほど復号失敗の発生率が高くなることに起因している．
本節では，長い塩基長のDNAを扱う際の精度の低下を抑制するための
符号化・復号アルゴリズムの改良手法を提案する．

HEDGESの符号化アルゴリズムでは，各ビット列$v_i$に対応する
出力塩基$C_i$は式\eqref{encode}により，
ストランドID，ビット位置，直前のビット列に基づく
ハッシュ関数を用いて連鎖的に決定される．
そのため，例えばストランド内のある位置でバースト誤りが発生した場合，
後続の塩基配列の復号に対しても連鎖的に影響を及ぼし，正しい復号経路の
探索が困難になる．
そこで，提案手法では図\ref{fig:segment}のように長い塩基配列を数百nt程度の複数の短いセグメントに分割し，
各セグメントの先頭で，ハッシュ関数の入力として用いるビット位置$I_i$と
直前のビット列情報$B_i$を0にリセットして符号化する．
セグメントの区切り位置を特定するために，隣接するセグメント間には
特定のパターンを持つ10塩基程度のセパレータを挿入する．
復号時にはまず，セパレータの位置として予想される位置から前後30塩基程度の範囲を
探索し，セパレータのパターンに一致または類似する塩基配列を検出する．
セパレータの位置が特定できたら，各セグメントごとに
\ref{hedges_decoding}節で説明した復号アルゴリズムを適用し，
各セグメントの先頭では$I_i$と$B_i$を0にリセットした上でヒープを初期化して
復号を行う．
これにより，ヒープサイズが上限を超えることによる復号失敗を抑制し，
復号失敗が発生した場合でも，その影響をセグメント内だけに限定することができ，
次のセグメントから復号を再開することができる．
\begin{figure}
    \begin{center}
        \includegraphics[width=150mm]{segment.png}
        \caption{提案手法による符号化方式}\label{fig:segment}
    \end{center}
\end{figure}

\chapter{シミュレーション} \label{simulation}
\section{復号の探索効率化} \label{sim1}
\subsection{実験方法}
\ref{optimization}節で提案した報酬とペナルティの最適化手法の
性能をシミュレーションにより評価するために，まずはナノポアシーケンサーの読み出し特性を
評価し，行列$\bm{P}_{STATS}$を得る必要がある．
そのため，ランダムなバイナリデータをHEDGESで符号化した複数のDNAストランドに対し，
ナノポアシーケンサーによる電流波形をSquigulatorと呼ばれるシミュレータを用いて
シミュレーション行った\cite{squigulator}．
次に，シミュレーションされた電流波形に対してBonito Basecallerを用いて
CTC出力を取得し，\ref{ctc_output}節で述べた方法で$\bm{P}_{CTC}$を得た．
ここで，HEDGES符号化結果における$n$番目のDNAストランドの$i$番目の塩基を$C_i^{(n)}$と表し，
この塩基配列を$\{C_i^{(n)}\}$とする．また，
$\{C_i^{(n)}\}$のBasecallにおいて得られた
$\bm{P}_{CTC}$を$\bm{P}_{CTC}^{(n)}$と表すこととし，
$\bm{P}_{CTC}^{(n)}$の各行において，出力確率が最大となる塩基を選択することで
得られる塩基配列を$\{C'^{(n)}_i\}$と表す．この$\{C'^{(n)}_i\}$と$\{C_i^{(n)}\}$に対して
グローバルアラインメントを行い，各塩基ごとに
正しい読み出し，置換・挿入・消失エラーの発生数を集計した\cite{GOTOH1982705}．
これを全ての$n$について行い，集計することで
各事象の発生確率を計算し，行列$\bm{P}_{STATS}$を得た．

$\mu_{STATS\_ok}$，$\mu_{STATS\_sub}$，
$\mu_{STATS\_ins}$，$\mu_{STATS\_del}$はそれぞれ，正しい読み出し，置換エラー，
挿入エラー，消失エラー発生したときの$\bm{P}_{STATS}$のスコアの期待値であるから，
\begin{align}
  \mu_{STATS\_ok} &= \dfrac{\displaystyle \sum_{X \in \{A,C,G,T\}} p_{XX} \bm{P}_{STATS}[X,X]}{\displaystyle \sum_{X \in \{A,C,G,T\}} p_{XX}} \\
  \mu_{STATS\_sub} &= \dfrac{\displaystyle \sum_{X,Y \in \{A,C,G,T\}, X \neq Y} p_{XY} \bm{P}_{STATS}[X,Y]}{\displaystyle \sum_{X,Y \in \{A,C,G,T\}, X \neq Y} p_{XY}} \\
  \mu_{STATS\_ins} &= \dfrac{\displaystyle \sum_{Y \in \{A,C,G,T\}} p_{NY} \bm{P}_{STATS}[N,Y]}{\displaystyle \sum_{Y \in \{A,C,G,T\}} p_{NY}} \\
  \mu_{STATS\_del} &= \dfrac{\displaystyle \sum_{X \in \{A,C,G,T\}} p_{XN} \bm{P}_{STATS}[X,N]}{\displaystyle \sum_{X \in \{A,C,G,T\}} p_{XN}}
\end{align}
により計算される．
$\mu_{CTC\_ok}$，$\mu_{CTC\_sub}$，
$\mu_{CTC\_ins}$はそれぞれ，$\bm{P}_{CTC}$において
正しい読み出し，置換エラー，挿入エラーに対応するスコアの期待値であるから，
\begin{align}
  \mu_{CTC\_ok} &= \dfrac{1}{N}\sum_n \sum_i \bm{P}_{CTC}^{(n)}[i, C'^{(n)}_i] \\
  \mu_{CTC\_sub} &= \dfrac{1}{3N}\sum_n \sum_i \sum_{X \in \{A,C,G,T\}, X \neq C'^{(n)}_i} \bm{P}_{CTC}^{(n)}[i, X] \\
  \mu_{CTC\_ins} &= \dfrac{1}{N}\sum_n \sum_i \bm{P}_{CTC}^{(n)}[i, N]
\end{align}
により計算される．
ただし，$N$はBasecallされた全てのストランドにおける塩基数の総和を表す．

次に，式\eqref{opt1}から\eqref{opt4}に示した
固定の報酬とペナルティ$P_{ok}, P_{sub}, P_{ins}, P_{del}$
及び各補正項の重み付けパラメータ
$\alpha_{ok}, \alpha_{sub}, \alpha_{ins}, \alpha_{del},
\beta_{ok}, \beta_{sub}, \beta_{ins}$の最適な値を決定する必要がある．
ここで，$P_{ok}$には\cite{HEDGES}の研究で用いられた値を各符号化率ごとに使用し，
$P_{ok}$以外のパラメータを最適化した．
各パラメータの最適化は，復号におけるヒープの探索数を目的関数とした，
数値微分を用いた勾配降下法により行った．
具体的には，まずランダムに生成したバイナリデータをHEDGESで符号化し，
ナノポアシーケンサーでの読み出しをシミュレーションした上で
その電流波形に対してBasecallerを適用し，CTC出力を得た．
勾配降下法によるパラメータの最適化は，このCTC出力の復号を対象として，
以下の手順で行った．
\begin{enumerate}
  \item 最適化対象の各パラメータを適当な初期値で初期化する．
  \item 提案手法を用いて復号を実施し，復号が完了するまでのヒープの探索数を計測する．
  \item 各パラメータごとに微小な値$\Delta$を加えた場合の復号における
  ヒープの探索数を計測する．
  \item これらの値を用いて各パラメータに関する目的関数の勾配を計算する．
  \item 各パラメータを学習率$\eta$を用いて以下のように更新する．
  \begin{align}
    \bm{\theta} \leftarrow \bm{\theta} - \eta \dfrac{\partial J}{\partial \bm{\theta}}
  \end{align}
  ここで，$\theta$は最適化対象の各パラメータを表し，$J$は目的関数を表す．
  \item 2から5を一定回数繰り返す．
\end{enumerate}
パラメータの最適化については，ナノポアシーケンサーの読み出し特性に基づく補正項と
CTC出力に基づく補正項の両方を用いる場合と，それぞれ一方のみを用いる場合について
効果を検証するため，
$P_{sub}$,$P_{ins}$,$P_{del}$,$\alpha_{ok}$, $\alpha_{sub}$, $\alpha_{ins}$, $\alpha_{del}$,
$\beta_{ok}$, $\beta_{sub}$, $\beta_{ins}$の10個のパラメータに対して行うのに加えて，
$\alpha_{ok}=\alpha_{sub}=\alpha_{ins}=\alpha_{del}=0$として他の6個のパラメータに対してのみ
行う場合と
$\beta_{ok}=\beta_{sub}=\beta_{ins}=0$として他の7個のパラメータに対してのみ
行う場合についても実施した．
なお，これらの最適化は符号化率$0.75,0.60,0.50,0.33$について
それぞれ独立に行った．

以上の手順により得られた各パラメータを用いて，提案手法の復号性能を評価する．
まず，テストに用いるバイナリデータをHEDGESで符号化し，
得られたDNAストランドに対してナノポアシーケンサーでの読み出しをSquigulatorでシミュレーションする．
次に，シミュレーションされた電流波形に対して，Bonito BasecallerでBasecallを行う．
このとき，最終的な塩基配列だけでなく，CTCデコード前のCTCスコア行列も出力する．
このBasecall結果を用いて，既存手法および提案手法による復号を行い，ヒープの探索数，
復号失敗による消失ビット数，RS復号後の最終的なビット誤り率を計測する．
既存手法を用いた復号では，Basecallerが出力する塩基配列を入力とする．
提案手法を用いた復号では，CTCスコア行列を入力とし，ナノポアシーケンサーの読み出しに特性に基づく
補正項のみ用いる場合・CTC出力に基づく補正項のみ用いる場合・両方の補正項を用いる場合の3通りについて
評価を行う．このバイナリデータの符号化から復号までの一連のシミュレーションを，符号化率$0.75,0.60,0.50,0.33$について
それぞれ行う．

\subsection{実験条件}
行列$\bm{P}_{STATS}$を得るためのシミュレーションでは，ランダムに生成した400KBのバイナリデータを
HEDGESで符号化率0.50で符号化した．各ストランドの塩基長は400ntとし，
合計12240本のストランドを生成した．
Squigulatorを用いたナノポアシーケンサーの電流値シミュレーションでは，
MinION R9.4.1フローセルを想定したパラメータ設定を用いた\cite{squigulator}．
Bonito Basecallerのモデルには，既存の学習済みモデルであるdna\_r9.4.1@v2
をHEDGESで符号化したDNAの読み出しに向けてファインチューニングしたものを使用した\cite{bonito}．
ファインチューニング用の学習データには，ランダムに生成した200KBのバイナリデータを
HEDGESで符号化率0.50，塩基長400ntで符号化して得られた6120本のDNAストランドと，
これらのストランドに対してSquigulatorでシミュレーションした電流波形を用いた．
dna\_r9.4.1@v2の重みを初期値として，バッチサイズを64として1エポックあたり75ステップ
の学習を行い，エポック数は50としてファインチューニングを行った．
Squigulatorのシミュレーション条件とBasecallerに使用するモデルは
以降の全てのシミュレーションで同様に使用した．
$\{C^{(n)}_i\}$と$\{C'^{(n)}_i\}$に対するアラインメントにはBiopythonの
Gotohアルゴリズムを用いたグローバルアラインメントを使用した\cite{biopython,GOTOH1982705}．

パラメータの最適化では，ランダムに生成した400KBのバイナリデータを符号化率
$0.75,0.60,0.50,0.33$で塩基長を400ntとしてHEDGES符号化したものに対して
電流波形シミュレーション・Basecallを行って得られたCTC出力を用いた．
$P_{ok}$は各符号化率ごとに表\ref{tab:fixed_reward}に示す固定の値を使用した．
各パラメータの初期値は$P_{sub}=P_{ins}=P_{del}=1.0$，
$\alpha_{ok}=\alpha_{sub}=\alpha_{ins}=\alpha_{del}=0.0$，
$\beta_{ok}=\beta_{sub}=\beta_{ins}=0.0$とした．
学習率は符号化率ごとに表\ref{tab:learning_rate}に示す値を使用し，パラメータの更新を300回繰り返した．
\begin{table}
  \centering
  \begin{minipage}{0.48\linewidth}
    \centering
    \caption{符号化率ごとの報酬値$P_{ok}$}
    \label{tab:fixed_reward}
    \begin{tabular}{c|c}
      符号化率 & $P_{ok}$ \\
      \hline
      0.75 & -0.035 \\
      0.60 & -0.082 \\
      0.50 & -0.127 \\
      0.33 & -0.229 \\
    \end{tabular}
  \end{minipage}
  \hfill
  \begin{minipage}{0.48\linewidth}
    \centering
    \caption{符号化率ごとの学習率$\eta$}
    \label{tab:learning_rate}
    \begin{tabular}{c|c}
      符号化率 & $\eta$ \\
      \hline
      0.75 & $1.3 \times 10^{-7}$ \\
      0.60 &  $4.1 \times 10^{-7}$\\
      0.50 &  $1.0 \times 10^{-6}$ \\
      0.33 &  $3.8 \times 10^{-6}$ \\
    \end{tabular}
  \end{minipage}
\end{table}
なお，$\bm{P}_{STATS}$を得るためのシミュレーション，
Bonito Basecallerのファインチューニング，
パラメータの最適化に用いたランダムなバイナリデータは全て独立に生成したものである．

既存手法と提案手法の復号性能評価では，
テスト用のバイナリデータとして「こころ」(夏目漱石著)の全文のテキストデータ(UTF-8形式)を
青空文庫から取得し，ルビ部分(《…》で囲まれた部分)を正規表現により除去した
ものを使用した\cite{kokoro}．このデータのサイズは481158バイトである．
既存手法及び提案手法による復号において，ヒープの上限サイズは1000000とした．

\subsection{結果と考察}
ナノポアシーケンサーの読み出し特性の評価において，
ラベル$\{N,A,C,G,T\}$間の遷移確率は表\ref{tab:transition_matrix}に
示すように得られた．
\begin{table}
  \centering
  \caption{ラベル間の遷移確率}
  \label{tab:transition_matrix}
  \begin{tabular}{c|ccccc}
    入力$\backslash$出力 & N & A & C & G & T \\
    \hline
    N & $0.000$ & $3.11 \times 10^{-4}$ & $3.11 \times 10^{-4}$ & $3.18 \times 10^{-4}$ & $3.86 \times 10^{-4}$  \\
    A & $9.28 \times 10^{-4}$ & $0.232$ & $5.03 \times 10^{-4}$ & $1.01 \times 10^{-3}$ & $3.94 \times 10^{-5}$ \\
    C & $5.95 \times 10^{-4}$ & $3.10 \times 10^{-4}$ & $0.244$ & $3.56 \times 10^{-4}$ & $1.27 \times 10^{-4}$ \\
    G & $8.27 \times 10^{-4}$ & $9.00 \times 10^{-4}$ & $6.60 \times 10^{-4}$ & $0.269$ & $5.13 \times 10^{-5}$ \\
    T & $6.73 \times 10^{-4}$ & $4.36 \times 10^{-5}$ & $1.55 \times 10^{-4}$ & $5.85 \times 10^{-5}$ & $0.247$ \\
  \end{tabular}
\end{table}
この結果では，正しい読み取りは全体のうち99.1\%を占めており，
置換エラーは0.421\%，挿入エラーは0.133\%，消失エラーは0.302\%であった．
また，置換エラーはA,G間とC,T間で発生しやすい傾向が見られ，
特に，最も確率の低いA,T間の
置換と比べてA,G間の置換は約23倍の確率で発生することが分かった．
塩基ごとの置換エラー発生率の偏りは，
プリン塩基(A,G)とピリミジン塩基(C,T)の化学構造
の類似性に起因すると考えられている\cite{10.1371/journal.pone.0257521}．
NからA,C,G,Tへの遷移で表わされる挿入エラーは，
各塩基に対して同程度の確率で発生していた．
A,C,G,TからNへの遷移で表わされる消失エラーは，
A,GにおいてC,Tよりも比較的高い確率で発生していた．
この結果から得られた行列$\bm{P}_{STATS}$は付録の
式\eqref{eq:appendix_P_STATS}，各補正項の期待値は表\ref{tab:appendix_mu_values}に示す．
各符号化率ごとに最適化されたペナルティと補正項の重み付けパラメータは
付録の表\ref{tab:appendix_params_p}および表\ref{tab:appendix_params_alpha_beta}に示す．

既存手法と提案手法の復号性能評価における，
ストランド1本あたりの平均ヒープ探索数，復号失敗によるビット消失率，
RS復号後の最終的なビット誤り率を
表\ref{tab:results_heap}, \ref{tab:results_deletion}, 
\ref{tab:results_final_ber}に示す．
ただし，各表において，
「Default」は既存手法によるBasecallと復号を表し，
「STATS」はナノポアシーケンサーの読み出し特性に基づく補正項のみを適用した場合を表し，
「CTC」はCTC出力に基づく補正項のみを適用した場合を表し，
「CTC+STATS」は両方の補正項を適用した場合を表す．
\begin{table}
  \centering
  \caption{ストランド1本あたりの平均ヒープ探索数}
  \label{tab:results_heap}
  \begin{tabular}{c|cccc}
    \hline
    code rate & 0.75 & 0.6 & 0.5 & 0.33 \\
    \hline
    Default & 135550 & 45219 & 21291 & 12290 \\
    STATS & 77281 & 23707 & 10893 & 4785 \\
    CTC & 53098 & 17966 & 9353 & 4354 \\
    CTC+STATS & 48507 & 14972 & 7625 & 3894 \\
    \hline
  \end{tabular}
\end{table}
\begin{table}
  \centering
  \caption{ビット消失率}
  \label{tab:results_deletion}
  \begin{tabular}{c|cccc}
    \hline
    code rate & 0.75 & 0.6 & 0.5 & 0.33 \\
    \hline
    Default & 0.03083 & 0.00949 & 0.00341 & 0.00328 \\
    STATS & 0.00741 & 0.00376 & 0.00121 & 0.00076 \\
    CTC & 0.00789 & 0.00265 & 0.00111 & 0.00055 \\
    CTC+STATS & 0.00693 & 0.00229 & 0.00069 & 0.00056 \\
    \hline
  \end{tabular}
\end{table}
\begin{table}
  \centering
  \caption{RS復号後のビット誤り率}
  \label{tab:results_final_ber}
  \begin{tabular}{c|cccc}
    \hline
    code rate & 0.75 & 0.6 & 0.5 & 0.33 \\
    \hline
    Default & 0.022981 & $<10^{-6}$ & $<10^{-6}$ & $<10^{-6}$ \\
    STATS & 0.059977 & $<10^{-6}$ & $<10^{-6}$ & $<10^{-6}$ \\
    CTC & 0.008228 & $<10^{-6}$ & $<10^{-6}$ & $<10^{-6}$ \\
    CTC+STATS & 0.005173 & $<10^{-6}$ & $<10^{-6}$ & $<10^{-6}$ \\
    \hline
  \end{tabular}
\end{table}
実験結果では，提案手法を用いることで，各符号化率において
既存手法と比べてヒープ探索数を削減し，復号失敗率を低減することができた．
ナノポアシーケンサーの読み出し特性に基づく補正項のみ適用した場合，
ヒープ探索数が43\%から61\%削減され，ビット消失率は60\%から77\%低減した．
CTC出力に基づく補正項のみ適用した場合，
ヒープ探索数が56\%から65\%削減され，ビット消失率は68\%から83\%低減した．
また，これら両方の補正項を適用した場合には，
ヒープ探索数は64\%から68\%削減され，ビット消失率は76\%から83\%低減し，
もっとも良好な結果が得られた．
さらに，RS復号後の最終的なビット誤り率については，符号化率0.75において，
両方の補正項を適用した場合，既存手法と比べて77\%の誤り率低減が達成された．
以上の結果から，提案手法により復号の探索が効率化されると同時に，
復号失敗によるビット消失率が低減されるため，最終的な復号精度の向上にも寄与することが
示された．

\section{ロングリードに向けた符号化アルゴリズムの改良}
\subsection{実験手法}
\ref{long_read_encoding}節で提案した符号化・復号アルゴリズムの改良手法の
性能をシミュレーションにより評価するために，
まず既存のHEDGES符号化アルゴリズムにより，テスト用のバイナリデータを
符号化した．得られたDNAストランドに対して\ref{sim1}節の実験
と同様の手法で電流波形のシミュレーションとBasecallを行った．
このBasecall結果に対して\ref{optimization}節の提案手法
により復号を行い，各パラメータは\ref{sim1}節の実験で得られたものを使用した．
これをDNAストランド1本の塩基長を500ntから15000ntの範囲で変化させながら行い，
塩基長ごとのビット誤り率を計測した．

次に，同じバイナリデータを用いて，提案手法によるセグメント化を適用した符号化を
行い，同様に電流波形のシミュレーションとBasecallを行った．
復号においては，まずセパレータの位置を検出する必要があるため，
CTC出力に対して\ref{ctc_output}節で説明した方法で得られた$\bm{P}_{CTC}$
に対して以下の手順を用いてセパレータの位置を検出した．
\begin{enumerate}
  \item $n=l_{p} + l_{seg}$とする．ただし$l_p$はプライマー長，$l_{seg}$はセグメント長を表す．
  \item $n-30<k<n+30$を満たす整数$k$対して$S_{match}(k)$を以下の式で計算し，
  $S_{match}(k)$を最小とする$k$をセパレータの位置として選択し，これを$k'$とする．
  \begin{align}
    S_{match}(k) = \sum_{j=0}^{l_{sep}-1} \bm{P}_{CTC}[k+j, S[j]] \label{eq:separator_detection}
  \end{align}
  ただし$S[j]$はセパレータ配列の$j$番目の塩基を表し，$l_{sep}$はセパレータ配列の長さを表す．
  \item $n=k' + l_{sep}+l_{seg}$とする．
  \item 2から3を繰り返し，全てのセグメントのセパレータ位置を検出する．
\end{enumerate}
セパレータを検出後，セグメントごとに\ref{optimization}節の提案手法を用いて
復号を行った．
これをセグメント長は一定として，セグメント数を変化させることでDNAストランド全体の
塩基長を500nt程度から15000nt程度の範囲で変化させながら行い，
塩基長ごとのビット誤り率を計測した．

これらのシミュレーション結果を比較することで提案手法による
符号化・復号アルゴリズムの性能を評価した．

\subsection{実験条件}
テスト用に用いたバイナリデータは\ref{sim1}節の実験で使用したものと同じである．
また，Squigulatorによる電流値シミュレーションのパラメータ設定，
Basecallerのモデルについても\ref{sim1}節の実験と同様に行った．
既存手法及び提案手法による符号化における符号化率は0.60とした．
提案手法におけるセグメント化では，セグメント長は341ntとし，
セパレータは10ntの塩基配列"GTACTGCATG"とした．
復号におけるヒープ探索では既存手法，提案手法ともに
ヒープの上限サイズは1000000とした．

\subsection{結果と考察}
既存手法と提案手法における，DNAストランドの塩基長とビット誤り率の関係を
図\ref{fig:long_read_results}に示す．
実験結果では，既存手法では\cite{HEDGES}の研究の報告と同様に，
塩基長が大きくなるほどビット誤り率が直線的に増加することを確認した．
一方，提案手法においては塩基長が長くなってもビット誤り率は
ほぼ変化しなかった．
既存手法における復号精度の低下は，
復号におけるヒープ探索数の増加に伴う復号失敗率の増加が主な要因であり，
提案手法ではセグメントごとにハッシュ関数の入力とヒープをリセットすることで，
ヒープサイズを抑えつつ，復号失敗が発生した場合においても
次のセグメントからの復号を継続できるため，復号精度の低下を抑制できたと考えられる．
\begin{figure}
  \centering
  \includegraphics[width=120mm]{longread.png}
  \caption{塩基長とビット誤り率の関係}
  \label{fig:long_read_results}
\end{figure}
\chapter{結論}
本研究では，DNAストレージの読み出しにおいてナノポアシーケンサーを用いることを前提とした
誤り訂正手法を提案し，その性能をシミュレーションにより評価した．
既存手法であるHEDGESは，DNAストレージにおけるシーケンス制約を満たしつつ
挿入・消失・置換エラーへの耐性を持つ誤り訂正符号であるが，
その復号アルゴリズムにおいて，
ナノポアシーケンサーでのDNA読み出しを前提とした最適化が行われていないという課題と，
DNAストランドの塩基長が長い場合に復号精度が低下するという課題が存在した．

本研究では，これらの課題を解決するために，
まずHEDGESの復号アルゴリズムにおいて，
ナノポアシーケンサーの統計的な読み出し特性とBasecallerのCTC出力を
考慮した探索手法を提案した．
実験結果より，提案手法では既存手法と比較して複号アルゴリズムにおける探索数を
64\%から68\%削減し，
復号失敗によるビット消失率を76\%から83\%低減できることを示した．
さらに，ロングリードに向けた符号化・復号アルゴリズムの改良を提案し，
セグメント化による手法を用いることで長い塩基長のDNA配列を扱う場合の
復号精度の低下を抑制できることを示した．

今後の課題としては，以下の点が挙げられる．
第一に，ナノポアシーケンサーの出力特性をより詳細にモデル化することである．
本研究では，ラベル間の遷移確率のみを考慮した単純なモデルを用いたが，
塩基配列のコンテキスト依存性や，バースト的なエラー発生など，
より複雑な特性を考慮することで，復号における探索をより最適化できる可能性がある．
第二に，Basecallerの最新アーキテクチャに対応することである．
本研究で使用したBonitoはCNN-LSTM-CTC構成であるが，
最新のBasecallerではCRFを用いたアーキテクチャなど，より先進的な機械学習手法が採用されており，
これらに対応することで復号精度のさらなる向上が期待できる．
第三に，実際のDNAを用いた実験的検証である．
本研究はシミュレーションのみによる評価であるため，
実際に合成DNAを用いたナノポアシーケンサーでの読み出し実験を行うことで，
提案手法の実用性を検証する必要がある．


%======================================================================
%		謝辞
%======================================================================
\begin{acknowledgements}
本研究を進めるにあたり，ご指導・ご助言を賜りました佐藤高史教授に
深く感謝申し上げます．
研究会やミーティングを通じて多くの貴重なご指摘・ご助言をいただきました
粟野皓光准教授，橋本昌宜教授，上野嶺准教授，白井僚助教，新津葵一教授，劉昆洋助教
に深く感謝致します．日々の研究において様々な助言をいただきました
小池健文氏に深く感謝いたします．
研究室生活において様々な面から支えて頂いた佐藤高史研究室支援職員の
西山修子氏，上西香織氏に感謝致します．
最後に，日頃から様々なご支援，ご協力を頂きました
佐藤研究室，橋本研究室，新津研究室の皆様に感謝致します．
\end{acknowledgements}



%======================================================================
%		参考文献
%======================================================================
\bibliographystyle{kueethesis}
\bibliography{reference}



%======================================================================
%		付録
%======================================================================
\appendix


\end{document}
% Local Variables:
% fill-column: 70
% End:
